<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>修改final的值</title>
      <link href="/blog/2022/11/11/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%BF%AE%E6%94%B9final%E7%9A%84%E5%80%BC/"/>
      <url>/blog/2022/11/11/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%BF%AE%E6%94%B9final%E7%9A%84%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="反射修改final修饰的变量"><a href="#反射修改final修饰的变量" class="headerlink" title="反射修改final修饰的变量"></a>反射修改final修饰的变量</h1><blockquote><p>final我们都知道，被定义后不可修改，但是利用反射能不能修改成功呢</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Work &#123;&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    private final String finalName = &quot;张三&quot;;</span><br><span class="line">    private final int finalAge = 18;</span><br><span class="line">    private final Work finalWork = new Work();</span><br><span class="line">    </span><br><span class="line">    //get方法</span><br><span class="line">    ...getter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//我们先试着修改finalName</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Person person = new Person();</span><br><span class="line">    Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">    Field fieldName = clazz.getDeclaredField(&quot;finalName&quot;);</span><br><span class="line">    fieldName.setAccessible(true);</span><br><span class="line">    fieldName.set(person, &quot;李四&quot;);</span><br><span class="line">    System.out.println(person.getFinalName());</span><br><span class="line">&#125;</span><br><span class="line">//输出：张三</span><br></pre></td></tr></table></figure><blockquote><p>可以看到被final修饰的String没有修改成功，再试试对象</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Person person = new Person();</span><br><span class="line">//原来的work地址</span><br><span class="line">String workAddr = person.getFinalWork().toString();</span><br><span class="line">Field fieldWork = clazz.getDeclaredField(&quot;finalWork&quot;);</span><br><span class="line">fieldWork.setAccessible(true);</span><br><span class="line">fieldWork.set(person, new Work());</span><br><span class="line">System.out.println(workAddr);</span><br><span class="line">System.out.println(person.getFinalWork());</span><br><span class="line"></span><br><span class="line">//输出：</span><br><span class="line">com.cc.thread.Work@64616ca2</span><br><span class="line">com.cc.thread.Work@246ae04d</span><br></pre></td></tr></table></figure><blockquote><p>可以看到，对象即使被final修饰也可以通过反射修改，那这是为什么呢，为什么String不能被修改，普通对象却可以。<br>其实String值也被修改了，只是我们无法通过这个对象获取到修改后的值。</p></blockquote><blockquote><p>这就涉及到JVM的内联优化了：<br>内联函数，编译器将指定的函数体插入并取代每一处调用该函数的地方（上下文），从而节省了每次调用函数带来的额外时间开支。<br>简单的说，就是JVM在处理代码的时候会帮我们优化代码逻辑，比如上述的final变量，已知final修饰后不会被修改，所以获取这个变量的时候就直接帮你在编译阶段就给赋值了。</p></blockquote><blockquote><p>所以上述的getFinalName方法经过JVM编译内联优化后会变成：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String getFinalName() &#123;</span><br><span class="line">    return &quot;张三&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>那如果我直接获取finalName呢？</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//修改为public</span><br><span class="line">public final String finalName = &quot;张三&quot;;</span><br><span class="line"></span><br><span class="line">Field fieldName = clazz.getDeclaredField(&quot;finalName&quot;);</span><br><span class="line">fieldName.setAccessible(true);</span><br><span class="line">fieldName.set(person, &quot;李四&quot;);</span><br><span class="line">System.out.println(person.finalName);</span><br><span class="line"></span><br><span class="line">//输出：张三</span><br><span class="line"></span><br><span class="line">//因为System.out.println(person.finalName);会被编译成System.out.println(&quot;张三&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>那如何获取到我们修改后的值呢</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//通过反射获取</span><br><span class="line">fieldName.set(person, &quot;李四&quot;);</span><br><span class="line">System.out.println(fieldName.get(person));</span><br><span class="line"></span><br><span class="line">//输出：李四</span><br></pre></td></tr></table></figure><h1 id="无法修改final修饰的静态变量"><a href="#无法修改final修饰的静态变量" class="headerlink" title="无法修改final修饰的静态变量"></a>无法修改final修饰的静态变量</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//final修饰的静态变量通过反射也无法修改，会报出异常</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalAccessException: Can not set static final com.cc.thread.Work field com.cc.thread.Person.finalWork to com.cc.thread.Work</span><br><span class="line">at java.base/jdk.internal.reflect.UnsafeFieldAccessorImpl.throwFinalFieldIllegalAccessException(UnsafeFieldAccessorImpl.java:76)</span><br><span class="line">at java.base/jdk.internal.reflect.UnsafeFieldAccessorImpl.throwFinalFieldIllegalAccessException(UnsafeFieldAccessorImpl.java:80)</span><br><span class="line">at java.base/jdk.internal.reflect.UnsafeQualifiedStaticObjectFieldAccessorImpl.set(UnsafeQualifiedStaticObjectFieldAccessorImpl.java:77)</span><br><span class="line">at java.base/java.lang.reflect.Field.set(Field.java:780)</span><br><span class="line">at com.cc.thread.ReflectTest.main(ReflectTest.java:56)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式（十三）代理模式</title>
      <link href="/blog/2022/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2022/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote><p>为其他对象提供一种代理以控制对这个对象的访问。</p></blockquote><blockquote><p>想要在访问一个类做一些其他控制时，可以通过代理的方式解决。例如我们在不想修改源码的情况下，对某些方法的前后做一下其他操作。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">interface Action &#123;</span><br><span class="line">    void doAction();</span><br><span class="line">&#125;</span><br><span class="line">class RealObj implements Action &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doAction() &#123;</span><br><span class="line">        System.out.println(&quot;doAction...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProxyObj implements Action &#123;</span><br><span class="line"></span><br><span class="line">    private RealObj realObj;</span><br><span class="line"></span><br><span class="line">    public ProxyObj() &#123;</span><br><span class="line">        this.realObj = new RealObj();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doAction() &#123;</span><br><span class="line">        System.out.println(&quot;before do action...&quot;);</span><br><span class="line">        realObj.doAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Action action = new ProxyObj();</span><br><span class="line">    action.doAction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式（十二）状态模式</title>
      <link href="/blog/2022/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2022/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote><p>对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p></blockquote><ul><li>环境类（Context）角色：也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。</li><li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。</li><li>具体状态（Concrete State）角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//抽象状态类</span><br><span class="line">abstract class State &#123;</span><br><span class="line">    public abstract void handle(Context context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//具体状态A类</span><br><span class="line">class ConcreteStateA extends State &#123;</span><br><span class="line">    public void handle(Context context) &#123;</span><br><span class="line">        System.out.println(&quot;当前状态是 A.&quot;);</span><br><span class="line">        //自动切换状态</span><br><span class="line">        context.setState(new ConcreteStateB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//具体状态B类</span><br><span class="line">class ConcreteStateB extends State &#123;</span><br><span class="line">    public void handle(Context context) &#123;</span><br><span class="line">        System.out.println(&quot;当前状态是 B.&quot;);</span><br><span class="line">        //自动切换状态</span><br><span class="line">        context.setState(new ConcreteStateA());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//环境类</span><br><span class="line">class Context &#123;</span><br><span class="line">    private State state;</span><br><span class="line"></span><br><span class="line">    //定义环境类的初始状态</span><br><span class="line">    public Context() &#123;</span><br><span class="line">        this.state = new ConcreteStateA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //设置新状态</span><br><span class="line">    public void setState(State state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //读取状态</span><br><span class="line">    public State getState() &#123;</span><br><span class="line">        return (state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //对请求做处理</span><br><span class="line">    public void handle() &#123;</span><br><span class="line">        state.handle(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="状态模式和策略模式的区别"><a href="#状态模式和策略模式的区别" class="headerlink" title="状态模式和策略模式的区别"></a>状态模式和策略模式的区别</h1><ul><li>状态模式重点在各状态之间的切换，从而做不同的事情；而策略模式更侧重于根据具体情况选择策略，并不涉及切换。</li><li>状态模式不同状态下做的事情不同，而策略模式做的都是同一件事。例如，聚合支付平台，有支付宝、微信支付、银联支付，虽然策略不同，但最终做的事情都是支付，也就是说他们之间是可替换的。反观状态模式，各个状态的同一方法做的是不同的事，不能互相替换。</li><li>状态模式封装了对象的状态，而策略模式封装算法或策略。因为状态是跟对象密切相关的，它不能被重用；而策略模式通过从Context中分离出策略或算法，我们可以重用它们。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式（十一）组合模式</title>
      <link href="/blog/2022/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2022/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote><p>将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p></blockquote><ul><li>Component（抽象构件）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。</li><li>Leaf（叶子构件）：它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过异常等方式进行处理。</li><li>Composite（容器构件）：它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。</li></ul><h1 id="文件目录设计"><a href="#文件目录设计" class="headerlink" title="文件目录设计"></a>文件目录设计</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">//声明了文件夹类和文件类需要的方法（抽象构件）</span><br><span class="line">abstract class Component &#123;</span><br><span class="line">    public void add(Component component) &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;不支持添加操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print() &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;不支持打印操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//文件夹（容器构件）</span><br><span class="line">class Folder extends Component &#123;</span><br><span class="line">    //文件名</span><br><span class="line">    private String name;</span><br><span class="line">    //文件</span><br><span class="line">    private List&lt;Component&gt; componentList = new ArrayList&lt;Component&gt;();</span><br><span class="line">    //打印层级</span><br><span class="line">    public Integer level;</span><br><span class="line"></span><br><span class="line">    public Folder(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void add(Component component) &#123;</span><br><span class="line">        this.componentList.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(this.name);</span><br><span class="line">        if (this.level == null) &#123;</span><br><span class="line">            this.level = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder prefix = new StringBuilder();</span><br><span class="line">        for (int i = 0; i &lt; this.level; i++) &#123;</span><br><span class="line">            prefix.append(&quot;\t- &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (Component component : this.componentList) &#123;</span><br><span class="line">            if (component instanceof Folder)&#123;</span><br><span class="line">                ((Folder)component).level = this.level + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(prefix);</span><br><span class="line">            component.print();</span><br><span class="line">        &#125;</span><br><span class="line">        this.level = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//文件（叶子构件）</span><br><span class="line">class File extends Component &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public File(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Folder folder = new Folder(&quot;设计模式资料&quot;);</span><br><span class="line">    File note1 = new File(&quot;组合模式笔记.md&quot;);</span><br><span class="line">    File note2 = new File(&quot;工厂方法模式.md&quot;);</span><br><span class="line">    folder.add(note1);</span><br><span class="line">    folder.add(note2);</span><br><span class="line"></span><br><span class="line">    Folder codeFolder = new Folder(&quot;样例代码&quot;);</span><br><span class="line">    File readme = new File(&quot;README.md&quot;);</span><br><span class="line">    Folder srcFolder = new Folder(&quot;src&quot;);</span><br><span class="line">    File code1 = new File(&quot;组合模式示例.java&quot;);</span><br><span class="line"></span><br><span class="line">    srcFolder.add(code1);</span><br><span class="line">    codeFolder.add(readme);</span><br><span class="line">    codeFolder.add(srcFolder);</span><br><span class="line">    folder.add(codeFolder);</span><br><span class="line">    folder.print();</span><br><span class="line">&#125;</span><br><span class="line">//打印</span><br><span class="line">设计模式资料</span><br><span class="line">- 组合模式笔记.md</span><br><span class="line">- 工厂方法模式.md</span><br><span class="line">- 样例代码</span><br><span class="line">- - README.md</span><br><span class="line">- - src</span><br><span class="line">- - - 组合模式示例.java</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式（十）迭代器模式</title>
      <link href="/blog/2022/11/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8D%81%EF%BC%89%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2022/11/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8D%81%EF%BC%89%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote><p>提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部的表示。</p></blockquote><ul><li>抽象迭代器角色(Iterator)：系统提供的接口，包含 hasNext()、next()、remove() 等方法。</li><li>具体迭代器角色(concreteIterator)：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置</li><li>抽象聚合角色(Aggregation)：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。</li><li>具体聚合角色(ConcreteAggregation)：实现抽象聚合类，返回一个具体迭代器的实例。</li></ul><blockquote><p>如果集合元素是用不同的方式实现的，有数组，还有java的集合类，或其他方式，当要遍历这些集合元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，这时就可以考虑迭代器模式解决</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">//抽象迭代器角色</span><br><span class="line">interface Iterator &#123;</span><br><span class="line">    boolean hasNext();</span><br><span class="line">    Object next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//抽象聚合角色</span><br><span class="line">interface Container &#123;</span><br><span class="line">    Iterator getIterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//具体聚合角色（集合）</span><br><span class="line">class StudentArr implements Container &#123;</span><br><span class="line">    public List&lt;String&gt; names = Arrays.asList(&quot;Robert&quot; , &quot;John&quot; ,&quot;Julie&quot; , &quot;Lora&quot;);</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Iterator getIterator() &#123;</span><br><span class="line">        return new NameIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //具体迭代器角色</span><br><span class="line">    private class NameIterator implements Iterator &#123;</span><br><span class="line">        int index;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return index &lt; names.size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object next() &#123;</span><br><span class="line">            if(this.hasNext())&#123;</span><br><span class="line">                return names.get(index++);</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//具体聚合角色（数组）</span><br><span class="line">class StudentList implements Container &#123;</span><br><span class="line">    public String[] names = &#123;&quot;Robert&quot; , &quot;John&quot; ,&quot;Julie&quot; , &quot;Lora&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Iterator getIterator() &#123;</span><br><span class="line">        return new NameIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //具体迭代器角色</span><br><span class="line">    private class NameIterator implements Iterator &#123;</span><br><span class="line">        int index;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return index &lt; names.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object next() &#123;</span><br><span class="line">            if(this.hasNext())&#123;</span><br><span class="line">                return names[index++];</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Container arr = new StudentArr();</span><br><span class="line">    Container list = new StudentArr();</span><br><span class="line">    Iterator arrIterator = arr.getIterator();</span><br><span class="line">    Iterator listIterator = list.getIterator();</span><br><span class="line">    while (arrIterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(arrIterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    while (listIterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(listIterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式（九）模板模式</title>
      <link href="/blog/2022/11/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B9%9D%EF%BC%89%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2022/11/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B9%9D%EF%BC%89%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote><p>在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p></blockquote><blockquote><p>定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。</p></blockquote><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><blockquote><p>咖啡冲泡法</p></blockquote><ol><li>把水煮沸</li><li>用沸水冲泡咖啡</li><li>把咖啡倒进杯子</li><li>加糖和牛奶</li></ol><blockquote><p>茶冲泡法</p></blockquote><ol><li>把水煮沸</li><li>用沸水浸泡茶叶</li><li>把茶倒进杯子</li><li>加柠檬</li></ol><blockquote><p>两种冲泡法都采用了相同的算法：</p></blockquote><ol><li>把水煮沸</li><li>用沸水冲泡咖啡或茶</li><li>把饮料倒进杯子</li><li>在饮料内加入适当的调料</li></ol><blockquote><p>为泡茶和泡咖啡定义一个模板</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">abstract class CaffeineBeverage &#123;</span><br><span class="line">    //我们的模板方法</span><br><span class="line">    final void prepareRecipe() &#123;</span><br><span class="line">        //把水煮沸</span><br><span class="line">        boilWater();</span><br><span class="line">        //用沸水冲泡咖啡或茶</span><br><span class="line">        brew();</span><br><span class="line">        //把饮料倒进杯子</span><br><span class="line">        pourInCup();</span><br><span class="line">        //在饮料内加入适当的调料</span><br><span class="line">        addCondiments();</span><br><span class="line">    &#125;</span><br><span class="line">    void boilWater() &#123;&#125;</span><br><span class="line">    abstract void brew();</span><br><span class="line">    void pourInCup() &#123;&#125;</span><br><span class="line">    abstract void addCondiments();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>让子类实现某些步骤</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Tea extends CaffeineBeverage &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void brew() &#123;</span><br><span class="line">        System.out.println(&quot;用沸水浸泡茶叶&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    void addCondiments() &#123;</span><br><span class="line">        System.out.println(&quot;加柠檬&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="添加钩子"><a href="#添加钩子" class="headerlink" title="添加钩子"></a>添加钩子</h1><blockquote><p>子类可以覆盖customerWantsCondiments方法决定是否需要添加调料</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">final void prepareRecipe() &#123;</span><br><span class="line">    ...</span><br><span class="line">    //如果顾客想要调料，才去调用</span><br><span class="line">    if(customerWantsCondiments()) &#123;</span><br><span class="line">        //在饮料内加入适当的调料</span><br><span class="line">        addCondiments();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//这就是一个钩子，子类可以覆盖这个方法</span><br><span class="line">boolean customerWantsCondiments() &#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h1><blockquote><p>别调用（打电话给）我们，我们会调用（打电话给）你。<br>简单的说就是底层组件绝对不可以直接调用高层组件。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式（八）外观模式</title>
      <link href="/blog/2022/11/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%85%AB%EF%BC%89%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2022/11/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%85%AB%EF%BC%89%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote><p>提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。</p></blockquote><blockquote><p>例如在家观影，我们需要很多步骤：</p></blockquote><ol><li>将灯光调暗</li><li>放下屏幕</li><li>打开投影机</li><li>打开DVD播放器</li><li>开始播放DVD</li><li>…</li></ol><blockquote><p>我们希望在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class HomeTheaterFacade &#123;</span><br><span class="line">    private TheaterLights lights;</span><br><span class="line">    private Screen screen;</span><br><span class="line">    private Amplifier amp;</span><br><span class="line">    private CdPlayer dvd;</span><br><span class="line">    </span><br><span class="line">    //提供了一个统一的接口</span><br><span class="line">    public void watchMove(String movie) &#123;</span><br><span class="line">        //1. 将灯光调暗</span><br><span class="line">        lights.dim(10);</span><br><span class="line">        //2. 放下屏幕</span><br><span class="line">        screen.down();</span><br><span class="line">        //3. 打开投影机</span><br><span class="line">        amp.on();</span><br><span class="line">        //4. 打开DVD播放器</span><br><span class="line">        dvd.on();</span><br><span class="line">        //5. 开始播放DVD</span><br><span class="line">        dvd.play(movie);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最少知识原则"><a href="#最少知识原则" class="headerlink" title="最少知识原则"></a>最少知识原则</h1><blockquote><p>减少对象之间的交互，当你正在设计一个系统，不管是任何对象，你都要注意它所交互的类有哪些，并注意它和这些类是如何交互的。<br>这个原则希望我们在设计中，不要让太多的类耦合在一起，免得修改系统中一部分，会影响到其他部分。如果许多类之间相互依赖，<br>那么这个系统就会变成一个易碎的系统，它需要花许多成本维护，也会因为太复杂而太不容易被其他人了解。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式（七）适配器模式</title>
      <link href="/blog/2022/11/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%83%EF%BC%89%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2022/11/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%83%EF%BC%89%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote><p>将一个类的接口，转换成客户期望的另一个接口，适配器让原本不兼容的类可以合作无间。</p></blockquote><ul><li>目标角色（Target）：该角色定义把其他类转换为何种接口，也就是我们的期望接口。</li><li>被适配者角色（Adaptee）：你想把谁转换成目标角色，这个“谁”就是被适配者角色，它是已经存在的、运行良好的类或对象。</li><li>适配器角色（Adapter）：适配器模式的核心角色，其他两个角色都是已经存在的角色，而适配器角色是需要新建立的，它的职责非常简单：通过继承或是类关联的方式把源角色转换为目标角色。</li></ul><blockquote><p>例如：我们的需求就是将电源输入220V（适配者）转换为5V输出（目标）</p></blockquote><h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><blockquote><p>类适配器模式在编译时实现target（目标）接口。这种适配器模式使用了多个实现了期待的接口或者已经存在的接口的多态接口。比较典型的就是：target接口被创建为一个纯粹的接口，如Java不支持多继承的语言。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//目标角色</span><br><span class="line">interface PowerTarget &#123;</span><br><span class="line">    public int output5V();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//被适配者角色</span><br><span class="line">class PowerAdaptee &#123;</span><br><span class="line">    private int output = 220;</span><br><span class="line"></span><br><span class="line">    public int output220V() &#123;</span><br><span class="line">        System.out.println(&quot;电源输出电压：&quot; + output);</span><br><span class="line">        return output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//适配器角色</span><br><span class="line">class PowerAdapter extends PowerAdaptee implements PowerTarget &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int output5V() &#123;</span><br><span class="line">        int output = output220V();</span><br><span class="line">        System.out.println(&quot;电源适配器开始工作，此时输出电压是：&quot; + output);</span><br><span class="line">        output = output / 44;</span><br><span class="line">        System.out.println(&quot;电源适配器工作完成，此时输出电压是：&quot; + output);</span><br><span class="line">        return output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    PowerTarget target = new PowerAdapter();</span><br><span class="line">    target.output5V();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h1><blockquote><p>对象适配器模式在运行时实现target（目标）接口。在这种适配器模式中，适配器包装了一个类实例。在这种情况下，适配器调用包装对象实例的方法。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//适配器角色</span><br><span class="line">class PowerAdapter implements PowerTarget &#123;</span><br><span class="line">    private PowerAdaptee powerAdaptee;</span><br><span class="line"></span><br><span class="line">    public PowerAdapter(PowerAdaptee powerAdaptee) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.powerAdaptee = powerAdaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public int output5V() &#123;</span><br><span class="line">        int output = powerAdaptee.output220V();</span><br><span class="line">        System.out.println(&quot;电源适配器开始工作，此时输出电压是：&quot; + output);</span><br><span class="line">        output = output / 44;</span><br><span class="line">        System.out.println(&quot;电源适配器工作完成，此时输出电压是：&quot; + output);</span><br><span class="line">        return output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    PowerTarget target = new PowerAdapter(new PowerAdaptee());</span><br><span class="line">    target.output5V();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringAOP有哪些使用方式</title>
      <link href="/blog/2022/11/04/Spring/SpringAOP%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
      <url>/blog/2022/11/04/Spring/SpringAOP%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="ProxyFactory（不用容器）"><a href="#ProxyFactory（不用容器）" class="headerlink" title="ProxyFactory（不用容器）"></a>ProxyFactory（不用容器）</h1><blockquote><p>代理对象工程，封装了JDK动态代理和CGLIB</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">UserService target = new UserService();</span><br><span class="line">ProxyFactory proxyFactory = new ProxyFactory();</span><br><span class="line">proxyFactory.setTarget(target);</span><br><span class="line">proxyFactory.addAdvice(new MethodInterceptor() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(MethodInvocation invocation) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;before...&quot;);</span><br><span class="line">        Object object = invocation.proceed();</span><br><span class="line">        System.out.println(&quot;after...&quot;);</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">UserService proxy = (UserService) proxyFactory.getProxy();</span><br><span class="line">proxy.test();</span><br></pre></td></tr></table></figure><h1 id="ProxyFactoryBean"><a href="#ProxyFactoryBean" class="headerlink" title="ProxyFactoryBean"></a>ProxyFactoryBean</h1><blockquote><p>利用FactoryBean机制将代理对象作为一个bean</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public ProxyFactoryBean proxyFactoryBean() &#123;</span><br><span class="line">    UserService target = new UserService();</span><br><span class="line">    ProxyFactoryBean factoryBean = new ProxyFactoryBean();</span><br><span class="line">    factoryBean.setTarget(target);</span><br><span class="line">    factoryBean.addAdvice(new MethodInterceptor() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object invoke(MethodInvocation invocation) throws Throwable &#123;</span><br><span class="line">            System.out.println(&quot;before...&quot;);</span><br><span class="line">            Object object = invocation.proceed();</span><br><span class="line">            System.out.println(&quot;after...&quot;);</span><br><span class="line">            return object;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return factoryBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">    UserService userService = context.getBean(UserService.class);</span><br><span class="line">    userService.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="BeanNameAutoProxyCreator"><a href="#BeanNameAutoProxyCreator" class="headerlink" title="BeanNameAutoProxyCreator"></a>BeanNameAutoProxyCreator</h1><blockquote><p>指定某个beanName让Spring对其进行AOP</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public BeanNameAutoProxyCreator beanNameAutoProxyCreator() &#123;</span><br><span class="line">    BeanNameAutoProxyCreator proxyCreator = new BeanNameAutoProxyCreator();</span><br><span class="line">    proxyCreator.setBeanNames(&quot;userSe*&quot;);</span><br><span class="line">    proxyCreator.setInterceptorNames(&quot;methodInterceptor&quot;);</span><br><span class="line">    proxyCreator.setProxyTargetClass(true);</span><br><span class="line">    return proxyCreator;</span><br><span class="line">&#125;</span><br><span class="line">@Bean</span><br><span class="line">public MethodInterceptor methodInterceptor() &#123;</span><br><span class="line">    return new MethodInterceptor() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object invoke(MethodInvocation invocation) throws Throwable &#123;</span><br><span class="line">            System.out.println(&quot;before...&quot;);</span><br><span class="line">            Object object = invocation.proceed();</span><br><span class="line">            System.out.println(&quot;after...&quot;);</span><br><span class="line">            return object;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="DefaultAdvisorAutoProxyCreator"><a href="#DefaultAdvisorAutoProxyCreator" class="headerlink" title="DefaultAdvisorAutoProxyCreator"></a>DefaultAdvisorAutoProxyCreator</h1><blockquote><p>指定某个Advisor，让Spring对其匹配的Bean对象进行AOP</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public DefaultPointcutAdvisor defaultPointcutAdvisor() &#123;</span><br><span class="line">    NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut();</span><br><span class="line">    pointcut.addMethodName(&quot;test&quot;);</span><br><span class="line">    DefaultPointcutAdvisor defaultPointcutAdvisor = new DefaultPointcutAdvisor();</span><br><span class="line">    defaultPointcutAdvisor.setPointcut(pointcut);</span><br><span class="line">    defaultPointcutAdvisor.setAdvice(new MethodInterceptor() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object invoke(MethodInvocation invocation) throws Throwable &#123;</span><br><span class="line">            System.out.println(&quot;before...&quot;);</span><br><span class="line">            Object object = invocation.proceed();</span><br><span class="line">            System.out.println(&quot;after...&quot;);</span><br><span class="line">            return object;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return defaultPointcutAdvisor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public DefaultAdvisorAutoProxyCreator autoProxyCreator() &#123;</span><br><span class="line">    return new DefaultAdvisorAutoProxyCreator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile为什么不能保证原子性</title>
      <link href="/blog/2022/11/04/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/volatile%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7/"/>
      <url>/blog/2022/11/04/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/volatile%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>例如我定义了一个static int count = 0的静态变量，这个变量应该是所有线程共享的</p></blockquote><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><blockquote><p>每个线程都有自己的工作内存（栈内存），对变量的操作都是在工作内存中进行的，之后再将修改后的值返回到主存中。<br>这就带来了问题，有可能一个线程在将共享变量修改后，还没有来的及将缓存中的变量返回给主存中，另外一个线程就对共享变量进行修改，那么这个线程拿到的值是主存中未被修改的值。</p></blockquote><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><blockquote><p>volatile很好的保证了变量的可见性，被volatile修饰的变量进行写操作的时候，能保证修改的值立即被更新的主存中，当有其他线程需要读取时，它会去内存中读取新值。</p></blockquote><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><blockquote><p>虽然volatile能保证修改的值立即能更新到主存，其他线程也会捕捉到被修改后的值，但是它无法保证原子性。<br>举个例子，比如count++这样的操作，会首先从主存中读取到count的值，然后再将count+1，最后再将新的值赋给count。<br>线程A首先得到了count的初始值100，但是还没来得及修改，就阻塞了，这时线程B开始了，它也得到了count的值，由于count的值未被修改，即使是被volatile修饰，主存的变量还没变化，那么线程B得到的值也是100，之后对其进行加1操作，得到101后，将新值写入到缓存中，再刷入主存中。根据可见性的原则，这个主存的值可以被其他线程可见。<br>但是线程A已经读取到了count的值为100，也就是说读取的这个原子操作已经结束了，所以这个可见性来的有点晚，线程A阻塞结束后，继续将100这个值加1，得到101，再将值写到缓存，最后刷入主存，所以即便是volatile具有可见性，也不能保证对它修饰的变量具有原子性。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几种注册bean的方法</title>
      <link href="/blog/2022/11/03/Spring/%E6%B3%A8%E5%86%8Cbean%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/blog/2022/11/03/Spring/%E6%B3%A8%E5%86%8Cbean%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="简单方式"><a href="#简单方式" class="headerlink" title="简单方式"></a>简单方式</h1><blockquote><p>@Component(@Configuration, @Service, @Controller, @Repository)<br>@Bean<br>@Import<br>@ImportResource</p></blockquote><h1 id="实现BeanDefinitionRegistryPostProcessor接口"><a href="#实现BeanDefinitionRegistryPostProcessor接口" class="headerlink" title="实现BeanDefinitionRegistryPostProcessor接口"></a>实现BeanDefinitionRegistryPostProcessor接口</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyBeanDefinition implements BeanDefinitionRegistryPostProcessor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123;</span><br><span class="line">        AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();</span><br><span class="line">        beanDefinition.setBeanClass(AService.class);</span><br><span class="line">        registry.registerBeanDefinition(&quot;AService&quot;, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现FactoryBean接口（类似懒加载，需要的时候才调用getObject）"><a href="#实现FactoryBean接口（类似懒加载，需要的时候才调用getObject）" class="headerlink" title="实现FactoryBean接口（类似懒加载，需要的时候才调用getObject）"></a>实现FactoryBean接口（类似懒加载，需要的时候才调用getObject）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;userService&quot;)</span><br><span class="line">public class MyFactoryBean implements FactoryBean &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object getObject() throws Exception &#123;</span><br><span class="line">        return new UserService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        return UserService.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//打印</span><br><span class="line">System.out.println(context.getBean(&quot;userService&quot;));</span><br><span class="line">---- com.cc.service.UserService@3b718392</span><br><span class="line">System.out.println(context.getBean(&quot;&amp;userService&quot;));</span><br><span class="line">---- com.cc.config.MyFactoryBean@7668d560</span><br><span class="line"></span><br><span class="line">//这种方式注册bean，成员属性不会自动注入</span><br><span class="line">@Autowired</span><br><span class="line">private OrderService orderService;</span><br><span class="line">打印的orderService为null</span><br></pre></td></tr></table></figure><h2 id="实现SmartFactoryBean接口"><a href="#实现SmartFactoryBean接口" class="headerlink" title="实现SmartFactoryBean接口"></a>实现SmartFactoryBean接口</h2><blockquote><p>SmartFactoryBean继承了FactoryBean，提供了isEagerInit方法，判断是否在容器初始化的时候就加载bean</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;userService&quot;)</span><br><span class="line">public class MySmartFactoryBean implements SmartFactoryBean &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object getObject() throws Exception &#123;</span><br><span class="line">        return new UserService();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        return UserService.class;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean isEagerInit() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ApplicationContext注册bean"><a href="#ApplicationContext注册bean" class="headerlink" title="ApplicationContext注册bean"></a>ApplicationContext注册bean</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">    context.register(UserService.class);</span><br><span class="line">//  context.registerBean(&quot;userService&quot;, UserService.class, UserService::new);</span><br><span class="line">    System.out.println(context.getBean(&quot;userService&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">    AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();</span><br><span class="line">    beanDefinition.setBeanClass(UserService.class);</span><br><span class="line">    context.registerBeanDefinition(&quot;userService&quot;, beanDefinition);</span><br><span class="line">    System.out.println(context.getBean(&quot;userService&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kong配置</title>
      <link href="/blog/2022/11/03/Kong/kong%E9%85%8D%E7%BD%AE/"/>
      <url>/blog/2022/11/03/Kong/kong%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="yum安装kong"><a href="#yum安装kong" class="headerlink" title="yum安装kong"></a>yum安装kong</h1><ol><li>sudo yum install kong-2.6.0.amd64.rpm</li><li>sudo ln -s /usr/local/bin/kong kong</li><li>sudo ./kong config init</li><li>sudo ./kong config -c kong.conf parse kong.yml</li><li>sudo ./kong restart</li></ol><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><blockquote><p>/etc/kong</p></blockquote><h2 id="配置检查"><a href="#配置检查" class="headerlink" title="配置检查"></a>配置检查</h2><blockquote><p>kong config -c kong.conf parse kong.yml</p></blockquote><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><blockquote><p>kong restart</p></blockquote><h2 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h2><blockquote><p>/usr/local/share/lua/5.1/kong</p></blockquote><h2 id="kong-yml（示例）"><a href="#kong-yml（示例）" class="headerlink" title="kong.yml（示例）"></a>kong.yml（示例）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">_format_version: &quot;2.1&quot;</span><br><span class="line">_transform: true</span><br><span class="line">services:</span><br><span class="line">- name: operation</span><br><span class="line">  url: http://127.0.0.1:8888</span><br><span class="line">  routes:</span><br><span class="line">  - name: operation</span><br><span class="line">    paths:</span><br><span class="line">    - /</span><br><span class="line">    hosts: [&quot;operation.com&quot;]</span><br><span class="line">  plugins:</span><br><span class="line">  - name: ip-restriction</span><br><span class="line">    enabled: false</span><br><span class="line">    config:</span><br><span class="line">      deny: [&quot;127.0.0.1&quot;]</span><br><span class="line">  - name: rate-limiting</span><br><span class="line">    enabled: false</span><br><span class="line">    config:</span><br><span class="line">      second: 1</span><br><span class="line">- name: operation-api</span><br><span class="line">  host: operation-up</span><br><span class="line">  protocol: http</span><br><span class="line">  port: 80</span><br><span class="line">  routes:</span><br><span class="line">  - name: operation-api</span><br><span class="line">    paths:</span><br><span class="line">    - /api</span><br><span class="line">    hosts: [&quot;operation.com&quot;]</span><br><span class="line">    strip_path: false</span><br><span class="line">    protocols:</span><br><span class="line">    - http</span><br><span class="line">    - https</span><br><span class="line">  - name: operation-api-access</span><br><span class="line">    paths:</span><br><span class="line">    - /api/access</span><br><span class="line">    hosts: [&quot;operation.com&quot;]</span><br><span class="line">    strip_path: false</span><br><span class="line">    protocols:</span><br><span class="line">    - http</span><br><span class="line">    - https</span><br><span class="line">    plugins:</span><br><span class="line">    - name: key-auth</span><br><span class="line">      config:</span><br><span class="line">        key_names: [&quot;accessKey&quot;]</span><br><span class="line">  plugins:</span><br><span class="line">  - name: correlation-id</span><br><span class="line">    config:</span><br><span class="line">      header_name: Kong-Request-ID</span><br><span class="line">      generator: uuid</span><br><span class="line"></span><br><span class="line">consumers:</span><br><span class="line">- username: operation-user</span><br><span class="line"></span><br><span class="line">upstreams:</span><br><span class="line">- name: operation-up</span><br><span class="line">  targets:</span><br><span class="line">  - target: 192.168.2.148:8280</span><br><span class="line">    weight: 100</span><br><span class="line">  - target: 192.168.2.149:8280</span><br><span class="line">    weight: 100</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kong </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式（六）命令模式</title>
      <link href="/blog/2022/11/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%85%AD%EF%BC%89%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2022/11/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%85%AD%EF%BC%89%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>将“请求”封装成对象，以便使用不同的请求，队列或日志来参数化其他对象。命令模式也支持可撤销的操作。</p></blockquote><ul><li>Command：命令接口，声明执行方法。</li><li>ConcreteCommand：命令接口的实现对象，是“虚”的实现，通常会持有接收者，通过调用接收者的方法，来完成命令要执行的操作。</li><li>Receiver：接收者，真正执行命令的对象。</li><li>Invoker：调用者，通常会持有命令，相当于使用命令模式的入口。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">//电灯，有开灯的功能（接收者）</span><br><span class="line">class Light &#123;</span><br><span class="line">    public void on() &#123;</span><br><span class="line">        System.out.println(&quot;开灯&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//电视（接收者）</span><br><span class="line">class TV &#123;</span><br><span class="line">    public void on() &#123;</span><br><span class="line">        System.out.println(&quot;打开电视&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Command &#123;</span><br><span class="line">    void execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//电视的命令</span><br><span class="line">class TVOnCommand implements Command &#123;</span><br><span class="line">    private TV tv;</span><br><span class="line">    public TVOnCommand(TV tv) &#123;</span><br><span class="line">        this.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        tv.on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//电灯的命令</span><br><span class="line">class LightOnCommand implements Command &#123;</span><br><span class="line">    private Light light;</span><br><span class="line">    public LightOnCommand(Light light) &#123;</span><br><span class="line">        this.light = light;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        light.on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//一个遥控器，能够执行插槽里的命令（调用者调用了execute命令）</span><br><span class="line">class SimpleRemoteControl &#123;</span><br><span class="line">    //有一个插槽持有命令，这个命令控制着一个装置</span><br><span class="line">    private Command[] onCommands = new Command[2];</span><br><span class="line"></span><br><span class="line">    public SimpleRemoteControl() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //设置插槽控制的命令</span><br><span class="line">    public void setSlot(int slot, Command command) &#123;</span><br><span class="line">        onCommands[slot] = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void buttonWasPressed(int slot) &#123;</span><br><span class="line">        onCommands[slot].execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//客户点击遥控器</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    SimpleRemoteControl control = new SimpleRemoteControl();</span><br><span class="line">    LightOnCommand lightOnCommand = new LightOnCommand(new Light());</span><br><span class="line">    TVOnCommand tvOnCommand = new TVOnCommand(new TV());</span><br><span class="line"></span><br><span class="line">    //把命令传给调用者</span><br><span class="line">    control.setSlot(0, lightOnCommand);</span><br><span class="line">    control.setSlot(1, tvOnCommand);</span><br><span class="line">    //按下按钮</span><br><span class="line">    control.buttonWasPressed(0);</span><br><span class="line">    control.buttonWasPressed(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="队列请求"><a href="#队列请求" class="headerlink" title="队列请求"></a>队列请求</h2><blockquote><p>想象有一个工作队列：你在某一端添加命令，然后另一端则是线程。线程进行下面的动作：从队列中取出一个命令，调用它的execute()方法，<br>等待这个调用完成，然后将此命令对象丢弃，再取出下一个命令。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring注解使用</title>
      <link href="/blog/2022/11/02/Spring/Spring%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/"/>
      <url>/blog/2022/11/02/Spring/Spring%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//直接使用</span><br><span class="line">@Value(&quot;8888&quot;)</span><br><span class="line">private String port;</span><br><span class="line"></span><br><span class="line">//$符号使用</span><br><span class="line">@Value(&quot;$&#123;server.port&#125;&quot;)</span><br><span class="line">private String port;</span><br><span class="line"></span><br><span class="line">//#符号使用，类似@Resource，按名称注入bean</span><br><span class="line">@Value(&quot;#&#123;myBService&#125;&quot;)</span><br><span class="line">private BService bService;</span><br><span class="line"></span><br><span class="line">//搭配注解使用</span><br><span class="line">@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Value(&quot;$&#123;server.port&#125;&quot;)</span><br><span class="line">public @interface LocalServerPort &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@LocalServerPort</span><br><span class="line">private String port;</span><br></pre></td></tr></table></figure><h1 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h1><h2 id="autowireCandidate属性"><a href="#autowireCandidate属性" class="headerlink" title="autowireCandidate属性"></a>autowireCandidate属性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//在自动注入时如果根据类型找到2个Bean，加了autowireCandidate=false不会注入给其他bean</span><br><span class="line">@Bean</span><br><span class="line">public BService bService() &#123;</span><br><span class="line">    return new BService();</span><br><span class="line">&#125;</span><br><span class="line">@Bean(autowireCandidate = false)</span><br><span class="line">public BService bService2() &#123;</span><br><span class="line">    return new BService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">//@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public BService bService() &#123;</span><br><span class="line">        return new BService();</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    public AService aService() &#123;</span><br><span class="line">        System.out.println(bService());</span><br><span class="line">        return new AService();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">        System.out.println(context.getBean(BService.class));</span><br><span class="line">        System.out.println(context.getBean(&quot;appConfig&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//申明了2个bean，如果没有加@Configuration输出：</span><br><span class="line">com.cc.service.BService@37091312</span><br><span class="line">com.cc.service.BService@282308c3</span><br><span class="line">com.cc.config.AppConfig@5dda14d0</span><br><span class="line">//加了@Configuration输出：</span><br><span class="line">com.cc.service.BService@37091312</span><br><span class="line">com.cc.service.BService@37091312</span><br><span class="line">com.cc.config.AppConfig$$EnhancerBySpringCGLIB$$68ece1d0@d4ab71a</span><br></pre></td></tr></table></figure><blockquote><p>可以发现加了@Configuration后默认会生成AppConfig的代理对象，当调用bService()方法的时候会执行代理逻辑判断容器中是否存在bService对象<br>通过加上参数@Configuration(proxyBeanMethods = false)，生成的AppConfig就不是代理对象</p></blockquote><h1 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h1><blockquote><p>includeFilters的使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface Cc &#123;</span><br><span class="line">&#125;</span><br><span class="line">//扫描自定义注解</span><br><span class="line">@ComponentScan(value = &quot;com.cc&quot;, includeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Cc.class))</span><br><span class="line">public class AppConfig &#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h1><blockquote><p>判断是否能够加载bean</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class MyConditional implements Condition &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            context.getClassLoader().loadClass(&quot;com.cc.service.AService&quot;);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//加在类上</span><br><span class="line">@Component</span><br><span class="line">@Conditional(value = MyConditional.class)</span><br><span class="line">public class BService &#123;&#125;</span><br><span class="line"></span><br><span class="line">//加在方法上</span><br><span class="line">@Bean</span><br><span class="line">@Conditional(value = MyConditional.class)</span><br><span class="line">public BService bService() &#123;</span><br><span class="line">    return new BService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h1><blockquote><p>会将导入进来的bean当做一个配置bean</p></blockquote><ol><li><p>如果没有指定包扫描路径，那么容器里只有BService没有AService</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Import(&#123;BService.class&#125;)</span><br><span class="line">public class AppConfig &#123;&#125;</span><br><span class="line"></span><br><span class="line">public class BService &#123;&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class AService &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果在BService定义包扫描，那么也能够加载到AService</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ComponentScan(value = &quot;com.cc&quot;)</span><br><span class="line">public class BService &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>BService实现了ImportSelector接口，会将selectImports方法返回的参数当作bean，那么容器里不会有BService，而存在AService</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class BService implements ImportSelector &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        return new String[] &#123;AService.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>实现ImportBeanDefinitionRegistrar接口，注册AService</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BService implements ImportBeanDefinitionRegistrar &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry, BeanNameGenerator importBeanNameGenerator) &#123;</span><br><span class="line">        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition();</span><br><span class="line">        AbstractBeanDefinition beanDefinition = beanDefinitionBuilder.getBeanDefinition();</span><br><span class="line">        beanDefinition.setBeanClass(AService.class);</span><br><span class="line">        registry.registerBeanDefinition(&quot;aService123&quot;, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lookup"><a href="#Lookup" class="headerlink" title="@Lookup"></a>@Lookup</h1><blockquote><p>如果是一个抽象类，正常情况下不会注册成一个bean，但是如果在成员方法上加上@Lookup注解，就会被注册成一个bean</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public abstract class AService &#123;</span><br><span class="line">    @Lookup(&quot;BService&quot;)</span><br><span class="line">    public BService test() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//生成了代理对象：com.cc.service.AService$$EnhancerBySpringCGLIB$$1e7ab2b8@3d9fc57a</span><br><span class="line">//调用test方法会从容器中查找BService并返回（就算代码里写的返回了null，或者直接返回new BService()）：com.cc.service.BService@d4ab71a</span><br></pre></td></tr></table></figure><h1 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h1><blockquote><p>注入的时候查找到多个bean时，会注入被@Primary注解标识的bean</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三级缓存解决循环依赖</title>
      <link href="/blog/2022/11/02/Spring/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>/blog/2022/11/02/Spring/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h2><blockquote><p>ABean创建–&gt;依赖了B属性–&gt;触发BBean创建—&gt;B依赖了A属性—&gt;需要ABean（但ABean还在创建过程中）<br>从而导致ABean创建不出来，BBean也创建不出来。</p></blockquote><h2 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h2><blockquote><p>根据class找到构造方法，获取一个普通对象–&gt;填充普通对象的属性（依赖注入）–&gt;如果普通对象某个方法被aop了，那么就会生成一个代理对象–&gt;最终将代理对象放入单例池中。</p></blockquote><p>对象有三种类型：</p><ol><li>刚实例化的普通对象（放在三级缓存）</li><li>提前进行AOP的不完整对象（放在二级缓存）</li><li>完整对象（一级缓存/单例池）</li></ol><h2 id="解决循环依赖的过程"><a href="#解决循环依赖的过程" class="headerlink" title="解决循环依赖的过程"></a>解决循环依赖的过程</h2><blockquote><p>创建A普通对象-&gt;填充A普通对象的属性B-&gt;去单例池找B对象（未找到）-&gt;creatingSet（标识正在创建中的对象）<br>-&gt;将A对象放入三级缓存中（存的是lambda表达式，为了后面创建代理对象）-&gt;创建B普通对象-&gt;填充B普通对象的属性A-&gt;出现循环依赖<br>-&gt;从单例池和二级缓存中找A对象（未找到）-&gt;从三级缓存中获取bean（如果需要提前aop则获取的是代理对象）<br>-&gt;获取到A代理对象存到二级缓存中（删除三级缓存中的普通对象）-&gt;B对象创建完成-&gt;A对象创建完成</p></blockquote><h2 id="为什么需要三级缓存，二级缓存不可以"><a href="#为什么需要三级缓存，二级缓存不可以" class="headerlink" title="为什么需要三级缓存，二级缓存不可以"></a>为什么需要三级缓存，二级缓存不可以</h2><blockquote><p>aop是在初始化后操作的，而循环依赖是发生在属性注入过程中的。<br>如果A普通对象需要aop，在B对象创建的过程中，从缓存里获取到的是A普通对象，而A普通对象又在初始化后变成了代理对象，这两个对象不是同一个对象，这就产生了冲突。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/blog/2022/11/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%9B%BE/"/>
      <url>/blog/2022/11/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>图是由一组顶点和一组能够将两个顶点相连的边组成的</p></blockquote><ul><li>无向图：边仅仅连接两个顶点，没有其他含义；</li><li>有向图：边不仅连接两个顶点，并且具有方向；</li></ul><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><ul><li>相邻顶点：当两个顶点通过一条边相连时，我们称这两个顶点是相邻的，并且称这条边依附于这两个顶点；</li><li>度：某个顶点的度就是依附于该顶点边的个数；</li><li>子图：一副图的所有边的子集（包含这些边依附的顶点）组成的图；</li><li>路径：是由边顺序连接的一系列的顶点组成；</li><li>环：是一条至少含有一条边且终点和起点相同的路径；</li><li>连通图：如果图中任意一个顶点都存在一条路径到达另一个顶点，那么这幅图就称之为连通图；</li><li>连通子图：一个非连通图由若干连通的部分组成，每一个连通的部分都可以称为该图的连通子图；</li></ul><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><ol><li>使用一个二维数组int[V][V] adj，把索引的值看做是顶点；</li><li>如果顶点v和顶点w相连，我们只需要将adj[v][w]和adj[w][v]的值设为1，否则设置为0即可；</li></ol><p><img src="/blog/img/md/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/graph01.png"></p><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><ol><li>使用一个大小为V的数组Queue[V]adj，把索引看做是顶点；</li><li>每个索引处adj[V]存储了一个队列，该队列中存储的是所有与该顶点相邻的其他顶点；</li></ol><p><img src="/blog/img/md/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/graph02.png"></p><h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Graph &#123;</span><br><span class="line">    //顶点数</span><br><span class="line">    private final int peakNum;</span><br><span class="line">    //边数</span><br><span class="line">    private int sideNum;</span><br><span class="line">    //邻接表</span><br><span class="line">    private Queue&lt;Integer&gt;[] table;</span><br><span class="line"></span><br><span class="line">    public Graph(int peakNum) &#123;</span><br><span class="line">        this.peakNum = peakNum;</span><br><span class="line">        this.sideNum = 0;</span><br><span class="line">        //初始化邻接表</span><br><span class="line">        this.table = new LinkedBlockingQueue[peakNum];</span><br><span class="line">        for (int i = 0; i &lt; table.length; i++) &#123;</span><br><span class="line">            this.table[i] = new LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取图中顶点的数量</span><br><span class="line">    public int getPeakNum() &#123;</span><br><span class="line">        return peakNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取图中边的数量</span><br><span class="line">    public int getSideNum() &#123;</span><br><span class="line">        return sideNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //向图中添加一条边v-w</span><br><span class="line">    public void addSide(int v, int w) &#123;</span><br><span class="line">        //在无向图中，边是没有方向的</span><br><span class="line">        this.table[v].offer(w);</span><br><span class="line">        this.table[w].offer(v);</span><br><span class="line">        sideNum++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取和顶点v相邻的所有顶点</span><br><span class="line">    public Queue&lt;Integer&gt; getAllPeak(int v) &#123;</span><br><span class="line">        return table[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><blockquote><p>在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找子结点，然后找兄弟结点。</p></blockquote><p><img src="/blog/img/md/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/graph03.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class DepthFirstSearch &#123;</span><br><span class="line"></span><br><span class="line">    //索引代表顶点，表示当前顶点是否已经被搜索</span><br><span class="line">    private boolean[] marked;</span><br><span class="line">    //记录有多少个顶点与s顶点相通</span><br><span class="line">    private int count;</span><br><span class="line"></span><br><span class="line">    public DepthFirstSearch(Graph graph, int s) &#123;</span><br><span class="line">        //初始化marked数组</span><br><span class="line">        this.marked = new boolean[graph.getPeakNum()];</span><br><span class="line">        count = 0;</span><br><span class="line"></span><br><span class="line">        dfs(graph, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用深度优先搜索找出G图中v顶点的所有连通顶点</span><br><span class="line">    private void dfs(Graph graph, int v) &#123;</span><br><span class="line">        marked[v] = true;</span><br><span class="line">        for (Integer peak : graph.getAllPeak(v)) &#123;</span><br><span class="line">            //判断当前顶点有没有被调用过，如果没有被搜索过，递归调用搜索</span><br><span class="line">            if(!marked[peak]) &#123;</span><br><span class="line">                dfs(graph, peak);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断w顶点与s顶点是否相通</span><br><span class="line">    public boolean marked(int w) &#123;</span><br><span class="line">        return marked[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取与顶点s相通的所有顶点的总数</span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //有10个顶点</span><br><span class="line">    Graph graph = new Graph(10);</span><br><span class="line">    graph.addSide(0, 5);</span><br><span class="line">    graph.addSide(0, 1);</span><br><span class="line">    graph.addSide(0, 2);</span><br><span class="line">    graph.addSide(0, 6);</span><br><span class="line">    graph.addSide(6, 4);</span><br><span class="line">    graph.addSide(5, 3);</span><br><span class="line">    graph.addSide(3, 4);</span><br><span class="line">    graph.addSide(5, 4);</span><br><span class="line">    //搜索0顶点</span><br><span class="line">    DepthFirstSearch search = new DepthFirstSearch(graph, 0);</span><br><span class="line">    //判断0顶点和3顶点是否相通</span><br><span class="line">    System.out.println(search.marked(3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><blockquote><p>在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找兄弟结点，然后找子结点。</p></blockquote><p><img src="/blog/img/md/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/graph04.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public class BreadthFirstSearch &#123;</span><br><span class="line">    //索引代表顶点，表示当前顶点是否已经被搜索</span><br><span class="line">    private boolean[] marked;</span><br><span class="line">    //记录有多少个顶点与s顶点相通</span><br><span class="line">    private int count;</span><br><span class="line">    //存储待搜索的邻接表顶点</span><br><span class="line">    private Queue&lt;Integer&gt; waitSearch;</span><br><span class="line"></span><br><span class="line">    public BreadthFirstSearch(Graph graph, int s) &#123;</span><br><span class="line">        //初始化marked数组</span><br><span class="line">        this.marked = new boolean[graph.getPeakNum()];</span><br><span class="line">        count = 0;</span><br><span class="line">        this.waitSearch = new LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        bfs(graph, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用广度优先搜索找出G图中v顶点的所有连通顶点</span><br><span class="line">    private void bfs(Graph graph, int v) &#123;</span><br><span class="line">        //把当前顶点v标识为已搜索</span><br><span class="line">        marked[v] = true;</span><br><span class="line">        //让顶点v进入队列，待搜索</span><br><span class="line">        waitSearch.offer(v);</span><br><span class="line">        while (!waitSearch.isEmpty()) &#123;</span><br><span class="line">            //弹出一个待搜索的顶点</span><br><span class="line">            Integer waitPeak = waitSearch.poll();</span><br><span class="line">            //遍历wait顶点的邻接表</span><br><span class="line">            for (Integer peak : graph.getAllPeak(waitPeak)) &#123;</span><br><span class="line">                if(!marked[peak]) &#123;</span><br><span class="line">                    waitSearch.offer(peak);</span><br><span class="line">                    //把当前顶点peak标识为已搜索</span><br><span class="line">                    marked[peak] = true;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断w顶点与s顶点是否相通</span><br><span class="line">    public boolean marked(int w) &#123;</span><br><span class="line">        return marked[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取与顶点s相通的所有顶点的总数</span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //有10个顶点</span><br><span class="line">    Graph graph = new Graph(10);</span><br><span class="line">    graph.addSide(0, 5);</span><br><span class="line">    graph.addSide(0, 1);</span><br><span class="line">    graph.addSide(0, 2);</span><br><span class="line">    graph.addSide(0, 6);</span><br><span class="line">    graph.addSide(6, 4);</span><br><span class="line">    graph.addSide(5, 3);</span><br><span class="line">    graph.addSide(3, 4);</span><br><span class="line">    graph.addSide(5, 4);</span><br><span class="line">    //搜索1顶点</span><br><span class="line">    BreadthFirstSearch search = new BreadthFirstSearch(graph, 0);</span><br><span class="line">    //判断0顶点和6顶点是否相通</span><br><span class="line">    System.out.println(search.marked(3));</span><br><span class="line">    System.out.println(search.getCount());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路径查找"><a href="#路径查找" class="headerlink" title="路径查找"></a>路径查找</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class DepthFirstPaths &#123;</span><br><span class="line">    //索引代表顶点，表示当前顶点是否已经被搜索</span><br><span class="line">    private boolean[] marked;</span><br><span class="line">    //起点</span><br><span class="line">    private int start;</span><br><span class="line">    //索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点</span><br><span class="line">    private int[] edgeTo;</span><br><span class="line"></span><br><span class="line">    public DepthFirstPaths(Graph graph, int s) &#123;</span><br><span class="line">        //初始化marked数组</span><br><span class="line">        this.marked = new boolean[graph.getPeakNum()];</span><br><span class="line">        start = s;</span><br><span class="line">        edgeTo = new int[graph.getPeakNum()];</span><br><span class="line">        dfs(graph, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用深度优先搜索找出G图中v顶点的所有连通顶点</span><br><span class="line">    private void dfs(Graph graph, int v) &#123;</span><br><span class="line">        marked[v] = true;</span><br><span class="line">        for (Integer peak : graph.getAllPeak(v)) &#123;</span><br><span class="line">            //判断当前顶点有没有被调用过，如果没有被搜索过，递归调用搜索</span><br><span class="line">            if (!marked[peak]) &#123;</span><br><span class="line">                edgeTo[peak] = v;</span><br><span class="line">                dfs(graph, peak);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断w顶点与s顶点是否存在路径</span><br><span class="line">    public boolean hasPathTo(int w) &#123;</span><br><span class="line">        return marked[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //找出从起点s到顶点v的路径（就是该路径经过的顶点）</span><br><span class="line">    public Stack&lt;Integer&gt; pathTo(int v) &#123;</span><br><span class="line">        if (!hasPathTo(v)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; pathStack = new Stack&lt;&gt;();</span><br><span class="line">        for (int i = v; i != start; i = edgeTo[i]) &#123;</span><br><span class="line">            pathStack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return pathStack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h1><blockquote><p>有向图是一副具有方向性的图，是由一组顶点和一组有方向的边组成的，每条方向的边都连着一对有序的顶点。</p></blockquote><ol><li>出度：由某个顶点指出的边的个数称为该顶点的出度。</li><li>入度：指向某个顶点的边的个数称为该顶点的入度。</li><li>有向路径：由一些列顶点组成，对于其中的每个顶点都存在一条有向边，从它指向序列中的下一个顶点。</li><li>有向环：一条至少含有一条边，且起点和终点相同的有向路径。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class Digraph &#123;</span><br><span class="line">    //顶点数</span><br><span class="line">    private final int peakNum;</span><br><span class="line">    //边数</span><br><span class="line">    private int sideNum;</span><br><span class="line">    //邻接表</span><br><span class="line">    private Queue&lt;Integer&gt;[] table;</span><br><span class="line"></span><br><span class="line">    public Digraph(int peakNum) &#123;</span><br><span class="line">        this.peakNum = peakNum;</span><br><span class="line">        this.sideNum = 0;</span><br><span class="line">        //初始化邻接表</span><br><span class="line">        this.table = new LinkedBlockingQueue[peakNum];</span><br><span class="line">        for (int i = 0; i &lt; table.length; i++) &#123;</span><br><span class="line">            this.table[i] = new LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取图中顶点的数量</span><br><span class="line">    public int getPeakNum() &#123;</span><br><span class="line">        return peakNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取图中边的数量</span><br><span class="line">    public int getSideNum() &#123;</span><br><span class="line">        return sideNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //向图中添加一条边v-w</span><br><span class="line">    public void addSide(int v, int w) &#123;</span><br><span class="line">        //在有向图中，边是有方向的</span><br><span class="line">        this.table[v].offer(w);</span><br><span class="line">        sideNum++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取和顶点v相邻的所有顶点</span><br><span class="line">    public Queue&lt;Integer&gt; getAllPeak(int v) &#123;</span><br><span class="line">        return table[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //该图的反向图</span><br><span class="line">    private Digraph reverse() &#123;</span><br><span class="line">        Digraph r = new Digraph(peakNum);</span><br><span class="line">        for (int v = 0; v &lt; peakNum; v++) &#123;</span><br><span class="line">            //获取由该顶点指出的所有边</span><br><span class="line">            for (Integer w : table[v]) &#123; //原图中表示的是由顶点v-&gt;w的边</span><br><span class="line">                r.addSide(w, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式（五）工厂模式</title>
      <link href="/blog/2022/11/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2022/11/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class SimplePizzaFactory &#123;</span><br><span class="line">    public Pizza createPizza(String type) &#123;</span><br><span class="line">        Pizza pizza = null;</span><br><span class="line">        if(type.equals(&quot;cheese&quot;)) &#123;</span><br><span class="line">            pizza = new CheesePizza();</span><br><span class="line">        &#125; else if(type.equals(&quot;veggie&quot;)) &#123;</span><br><span class="line">            pizza = new VeggiePizza();</span><br><span class="line">        &#125;</span><br><span class="line">        return pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><blockquote><p>定义一个创建对象的接口，但由子类决定要实例化的是哪一个。工厂方法让类把实例化推迟到子类。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">interface AbstractFactory &#123;</span><br><span class="line">    Pizza createPizza(String type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class NYPizzaFactory implements AbstractFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Pizza createPizza(String type) &#123;</span><br><span class="line">        Pizza pizza = null;</span><br><span class="line">        if(type.equals(&quot;cheese&quot;)) &#123;</span><br><span class="line">            pizza = new NYCheesePizza();</span><br><span class="line">        &#125; else if(type.equals(&quot;veggie&quot;)) &#123;</span><br><span class="line">            pizza = new NYVeggiePizza();</span><br><span class="line">        &#125;</span><br><span class="line">        return pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ChicagoPizzaFactory implements AbstractFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Pizza createPizza(String type) &#123;</span><br><span class="line">        Pizza pizza = null;</span><br><span class="line">        if(type.equals(&quot;cheese&quot;)) &#123;</span><br><span class="line">            pizza = new ChicagoCheesePizza();</span><br><span class="line">        &#125; else if(type.equals(&quot;veggie&quot;)) &#123;</span><br><span class="line">            pizza = new ChicagoVeggiePizza();</span><br><span class="line">        &#125;</span><br><span class="line">        return pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><blockquote><p>提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 手机产品接口</span><br><span class="line"> */</span><br><span class="line">interface IPhoneProduct &#123;</span><br><span class="line">    void start();</span><br><span class="line">    void callUp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 路由器产品接口</span><br><span class="line"> */</span><br><span class="line">interface IRouterProduct &#123;</span><br><span class="line">    void start();</span><br><span class="line">    void shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 抽象产品工厂（定义了同一个产品族的产品生产行为）</span><br><span class="line"> */</span><br><span class="line">interface IProductFactory &#123;</span><br><span class="line">    IPhoneProduct produceTelPhone();</span><br><span class="line">    IRouterProduct produceRouter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 华为手机产品</span><br><span class="line"> */</span><br><span class="line">class HuaweiPhone implements IPhoneProduct &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;开启华为手机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void callUp() &#123;</span><br><span class="line">        System.out.println(&quot;用华为手机打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 华为路由器产品</span><br><span class="line"> */</span><br><span class="line">class HuaweiRouter implements IRouterProduct &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;启动华为路由器&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void shutdown() &#123;</span><br><span class="line">        System.out.println(&quot;关闭华为路由器&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 小米手机产品</span><br><span class="line"> */</span><br><span class="line">class XiaomiPhone implements IPhoneProduct &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;开启小米手机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void callUp() &#123;</span><br><span class="line">        System.out.println(&quot;用小米手机打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 小米路由器产品</span><br><span class="line"> */</span><br><span class="line">class XiaomiRouter implements IRouterProduct &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;启动小米路由器&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void shutdown() &#123;</span><br><span class="line">        System.out.println(&quot;关闭小米路由器&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//华为产品工厂</span><br><span class="line">class HuaweiProductFactory implements IProductFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public IPhoneProduct produceTelPhone() &#123;</span><br><span class="line">        return new HuaweiPhone();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public IRouterProduct produceRouter() &#123;</span><br><span class="line">        return new HuaweiRouter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//小米产品工厂</span><br><span class="line">class XiaomiProductFactory implements IProductFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public IPhoneProduct produceTelPhone() &#123;</span><br><span class="line">        return new XiaomiPhone();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public IRouterProduct produceRouter() &#123;</span><br><span class="line">        return new XiaomiRouter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式（四）装饰者模式</title>
      <link href="/blog/2022/11/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%9B%9B%EF%BC%89%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2022/11/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%9B%9B%EF%BC%89%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote><p>装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p></blockquote><blockquote><p>装饰者在代码程序中适用于以下场景</p></blockquote><ol><li>用于扩展一个类的功能或给一个类添加附加职责。</li></ol><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><blockquote><p>例如想要购买一杯咖啡，我可以往咖啡里加入配料（牛奶、摩卡、豆浆、奶泡）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">abstract class AbstractCoffee &#123;</span><br><span class="line">    //价格</span><br><span class="line">    public abstract int price();</span><br><span class="line">    //具体内容</span><br><span class="line">    public abstract String info();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//具体的咖啡</span><br><span class="line">class BaseCoffee extends AbstractCoffee &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int price() &#123;</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String info() &#123;</span><br><span class="line">        return &quot;咖啡十元&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//抽象的装饰角色</span><br><span class="line">abstract class AbstractDecorator extends AbstractCoffee &#123;</span><br><span class="line"></span><br><span class="line">    private AbstractCoffee coffee;</span><br><span class="line"></span><br><span class="line">    public AbstractDecorator(AbstractCoffee coffee) &#123;</span><br><span class="line">        this.coffee = coffee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int price() &#123;</span><br><span class="line">        return coffee.price();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String info() &#123;</span><br><span class="line">        return coffee.info();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//具体的牛奶装饰角色</span><br><span class="line">class MilkDecorator extends AbstractDecorator &#123;</span><br><span class="line"></span><br><span class="line">    public MilkDecorator(AbstractCoffee coffee) &#123;</span><br><span class="line">        super(coffee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int price() &#123;</span><br><span class="line">        return super.price() + 5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String info() &#123;</span><br><span class="line">        return super.info() + &quot; + 牛奶5元&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DecoratorTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AbstractCoffee coffee = new BaseCoffee();</span><br><span class="line">        System.out.println(coffee.price());</span><br><span class="line">        System.out.println(coffee.info());</span><br><span class="line">        coffee = new MilkDecorator(coffee);</span><br><span class="line">        System.out.println(coffee.price());</span><br><span class="line">        System.out.println(coffee.info());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/blog/2022/11/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/blog/2022/11/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><blockquote><p>红黑树主要是对2-3树进行编码，红黑树背后的基本思想是用标准的二叉查找树（完全由2-结点构成）<br>和一些额外的信息（替换3-结点）来表示2-3数。我们将树中的链接分别为两种类型：</p></blockquote><ul><li>红链接：将2-结点连接起来构成一个3-结点；</li><li>黑链接：则是2-3树中的普通链接；</li></ul><p><img src="/blog/img/md/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/redBlackTree01.png"><br><img src="/blog/img/md/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/redBlackTree02.png"></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>红黑树是含有红黑链接并满足下列条件的二叉查找树：</p><ol><li>红链接均为左链接；</li><li>没有任何一个结点同时和两条红链接相连；</li><li>该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同；</li></ol><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><blockquote><p>当某个结点的左子结点为黑色，右子节点为红色，此时需要左旋。</p></blockquote><p><img src="/blog/img/md/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/redBlackTree03.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private Node rotateLeft(Node h) &#123;</span><br><span class="line">    //获取h结点的右子结点</span><br><span class="line">    Node x = h.right;</span><br><span class="line">    //让x的左子结点成为h的右子结点</span><br><span class="line">    h.right = x.left;</span><br><span class="line">    //让h成为x结点的左子结点</span><br><span class="line">    x.left = h;</span><br><span class="line">    //让x结点的color等于h结点的color</span><br><span class="line">    x.color = h.color;</span><br><span class="line">    //让结点的color变为红色</span><br><span class="line">    h.color = RED;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><blockquote><p>当某个结点的左子结点是红色，且左子结点的左子结点也是红色，需要右旋。</p></blockquote><p><img src="/blog/img/md/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/redBlackTree04.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private Node rotateRight(Node h) &#123;</span><br><span class="line">    //获取h结点的左子结点</span><br><span class="line">    Node x = h.left;</span><br><span class="line">    //让x的右子结点成为h的左子结点</span><br><span class="line">    h.left = x.right;</span><br><span class="line">    //让h成为x结点的右子结点</span><br><span class="line">    x.right = h;</span><br><span class="line">    //让x结点的color等于h结点的color</span><br><span class="line">    x.color = h.color;</span><br><span class="line">    //让结点的color变为红色</span><br><span class="line">    h.color = RED;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">public class RedBlackTree&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static final boolean RED = true;</span><br><span class="line">    private static final boolean BLACK = false;</span><br><span class="line"></span><br><span class="line">    //根节点</span><br><span class="line">    private Node root;</span><br><span class="line">    //元素数量</span><br><span class="line">    private int N;</span><br><span class="line"></span><br><span class="line">    private class Node &#123;</span><br><span class="line">        private Key key;</span><br><span class="line">        private Value value;</span><br><span class="line">        private Node left;</span><br><span class="line">        private Node right;</span><br><span class="line">        private boolean color;</span><br><span class="line"></span><br><span class="line">        public Node(Key key, Value value, Node left, Node right, boolean color) &#123;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.right = right;</span><br><span class="line">            this.color = color;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取树中元素的个数</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断当前结点的父指向链接是否为红色</span><br><span class="line">    private boolean isRed(Node x) &#123;</span><br><span class="line">        if (x == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return x.color == RED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //左旋</span><br><span class="line">    private Node rotateLeft(Node h) &#123;</span><br><span class="line">        //获取h结点的右子结点</span><br><span class="line">        Node x = h.right;</span><br><span class="line">        //让x的左子结点成为h的右子结点</span><br><span class="line">        h.right = x.left;</span><br><span class="line">        //让h成为x结点的左子结点</span><br><span class="line">        x.left = h;</span><br><span class="line">        //让x结点的color等于h结点的color</span><br><span class="line">        x.color = h.color;</span><br><span class="line">        //让结点的color变为红色</span><br><span class="line">        h.color = RED;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //右旋</span><br><span class="line">    private Node rotateRight(Node h) &#123;</span><br><span class="line">        //获取h结点的左子结点</span><br><span class="line">        Node x = h.left;</span><br><span class="line">        //让x的右子结点成为h的左子结点</span><br><span class="line">        h.left = x.right;</span><br><span class="line">        //让h成为x结点的右子结点</span><br><span class="line">        x.right = h;</span><br><span class="line">        //让x结点的color等于h结点的color</span><br><span class="line">        x.color = h.color;</span><br><span class="line">        //让结点的color变为红色</span><br><span class="line">        h.color = RED;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //颜色翻转</span><br><span class="line">    private void flipColors(Node h) &#123;</span><br><span class="line">        h.color = RED;</span><br><span class="line">        h.left.color = BLACK;</span><br><span class="line">        h.right.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //插入</span><br><span class="line">    public void put(Key key, Value value) &#123;</span><br><span class="line">        root = put(root, key, value);</span><br><span class="line">        //根结点的颜色总是黑色</span><br><span class="line">        root.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //在指定树中，完成插入操作，并返回添加元素后的新的树</span><br><span class="line">    private Node put(Node h, Key key, Value value) &#123;</span><br><span class="line">        if (h == null) &#123;</span><br><span class="line">            //数量+1</span><br><span class="line">            N++;</span><br><span class="line">            return new Node(key, value, null, null, RED);</span><br><span class="line">        &#125;</span><br><span class="line">        int cmp = key.compareTo(h.key);</span><br><span class="line">        if (cmp &lt; 0) &#123;</span><br><span class="line">            h.left = put(h.left, key, value);</span><br><span class="line">        &#125; else if (cmp &gt; 0) &#123;</span><br><span class="line">            h.right = put(h.right, key, value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            h.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        //左旋，当左子结点为黑色，右子节点为红色需要左旋</span><br><span class="line">        if (!isRed(h.left) &amp;&amp; isRed(h.right)) &#123;</span><br><span class="line">            h = rotateLeft(h);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //右旋，当左子结点和左子结点的左子结点都为红色</span><br><span class="line">        if (isRed(h.left) &amp;&amp; isRed(h.left.left)) &#123;</span><br><span class="line">            h = rotateRight(h);</span><br><span class="line">        &#125;</span><br><span class="line">        //颜色反转，左子结点和右子节点都为红色</span><br><span class="line">        if (isRed(h.left) &amp;&amp; isRed(h.right)) &#123;</span><br><span class="line">            flipColors(h);</span><br><span class="line">        &#125;</span><br><span class="line">        return h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据key，从树中找到对应的值</span><br><span class="line">    public Value get(Key key) &#123;</span><br><span class="line">        return get(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //从指定树中找到key对应的值</span><br><span class="line">    private Value get(Node h, Key key) &#123;</span><br><span class="line">        if (h == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int cmp = key.compareTo(h.key);</span><br><span class="line">        if (cmp &lt; 0) &#123;</span><br><span class="line">            return get(h.left, key);</span><br><span class="line">        &#125; else if (cmp &gt; 0) &#123;</span><br><span class="line">            return get(h.right, key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return h.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆</title>
      <link href="/blog/2022/11/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%A0%86/"/>
      <url>/blog/2022/11/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/blog/img/md/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/heapSort01.png"></p><blockquote><p>如果一节点的位置为k，则它的父节点的位置为k/2，而它的子节点位置分别为2k和2k+1</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">public class Heap&lt;T extends Comparable&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //用来存储元素的数组</span><br><span class="line">    private T[] items;</span><br><span class="line">    //记录堆中元素的个数</span><br><span class="line">    private int N;</span><br><span class="line"></span><br><span class="line">    public Heap(int capacity) &#123;</span><br><span class="line">        this.items = (T[]) new Comparable[capacity + 1];</span><br><span class="line">        this.N = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断i索引的值是否小于j索引的值</span><br><span class="line">    private boolean less(int i, int j) &#123;</span><br><span class="line">        return items[i].compareTo(items[j]) &lt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //交换堆中i索引和j索引处的值</span><br><span class="line">    private void exch(int i, int j) &#123;</span><br><span class="line">        T temp = items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //往堆中插入一个元素</span><br><span class="line">    public void insert(T t) &#123;</span><br><span class="line">        items[++N] = t;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除堆中最大的元素，并返回这个最大元素</span><br><span class="line">    public T delMax() &#123;</span><br><span class="line">        T max = items[1];</span><br><span class="line">        items[1] = items[N];</span><br><span class="line">        items[N] = null;</span><br><span class="line">        N--;</span><br><span class="line">        sink(1);</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //上浮，使索引k处的元素能在堆中处于一个正确的位置</span><br><span class="line">    private void swim(int k) &#123;</span><br><span class="line">        while (k &gt; 1 &amp;&amp; less(k / 2, k)) &#123;</span><br><span class="line">            exch(k, k / 2);</span><br><span class="line">            k = k / 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //下沉，使索引k处的元素能在堆中处于一个正确的位置</span><br><span class="line">    private void sink(int k) &#123;</span><br><span class="line">        while (2 * k &lt;= N) &#123;</span><br><span class="line">            //获取当前节点的子节点中较大值</span><br><span class="line">            int max;</span><br><span class="line">            if (2 * k + 1 &lt;= N) &#123; //有右子节点</span><br><span class="line">                if (less(2 * k, 2 * k + 1)) &#123;</span><br><span class="line">                    max = 2 * k + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    max = 2 * k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                max = 2 * k;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!less(k, max)) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(k, max);</span><br><span class="line">            k = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public class HeapSort &#123;</span><br><span class="line"></span><br><span class="line">    //判断heap堆索引i出的元素是否小于索引j处的元素</span><br><span class="line">    private static boolean less(Comparable[] heap, int i, int j) &#123;</span><br><span class="line">        return heap[i].compareTo(heap[j]) &lt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //交换heap堆中i索引和j索引处的值</span><br><span class="line">    private static void exch(Comparable[] heap, int i, int j) &#123;</span><br><span class="line">        Comparable temp = heap[i];</span><br><span class="line">        heap[i] = heap[j];</span><br><span class="line">        heap[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据原数组source，构造出堆heap</span><br><span class="line">    private static void createHeap(Comparable[] source, Comparable[] heap) &#123;</span><br><span class="line">        //把source拷贝到heap中，并对heap做下沉调整（从长度的一半处开始，往索引1处扫描）</span><br><span class="line">        System.arraycopy(source, 0, heap, 1, source.length);</span><br><span class="line"></span><br><span class="line">        for (int i = (heap.length / 2); i &gt; 0; i--) &#123;</span><br><span class="line">            sink(heap, i, heap.length - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //对source数组中的数据从小到大排序</span><br><span class="line">    private static void sort(Comparable[] source) &#123;</span><br><span class="line">        //构建堆</span><br><span class="line">        Comparable[] heap = new Comparable[source.length + 1];</span><br><span class="line">        createHeap(source, heap);</span><br><span class="line">        //定义一个变量，记录未排序的元素中最大的索引</span><br><span class="line">        int N = heap.length - 1;</span><br><span class="line">        //通过循环，交换1索引处的元素和排序的最大索引处的元素</span><br><span class="line">        while (N != 1) &#123;</span><br><span class="line">            exch(heap, 1, N);</span><br><span class="line">            //排序交换后最大元素所在的索引，让它不要参与堆的下沉调整</span><br><span class="line">            N--;</span><br><span class="line">            //需要对索引1处的元素进行下沉调整</span><br><span class="line">            sink(heap, 1, N);</span><br><span class="line">        &#125;</span><br><span class="line">        //把heap中的数据复制到原数组source中</span><br><span class="line">        System.arraycopy(heap, 1, source, 0, source.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //在heap堆中，堆target处的元素做下沉，范围是0~range</span><br><span class="line">    private static void sink(Comparable[] heap, int target, int range) &#123;</span><br><span class="line">        while (2 * target &lt;= range) &#123;</span><br><span class="line">            //获取当前节点的子节点中较大值</span><br><span class="line">            int max;</span><br><span class="line">            if (2 * target + 1 &lt;= range) &#123; //有右子节点</span><br><span class="line">                if (less(heap, 2 * target, 2 * target + 1)) &#123;</span><br><span class="line">                    max = 2 * target + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    max = 2 * target;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                max = 2 * target;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!less(heap, target, max)) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(heap, target, max);</span><br><span class="line">            target = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/blog/2022/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/blog/2022/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">public class BinaryTree&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //根节点</span><br><span class="line">    private Node root;</span><br><span class="line">    //记录树中元素的个数</span><br><span class="line">    private int N;</span><br><span class="line"></span><br><span class="line">    private class Node &#123;</span><br><span class="line">        //存储键</span><br><span class="line">        public Key key;</span><br><span class="line">        //存储值</span><br><span class="line">        private Value value;</span><br><span class="line">        //左子节点</span><br><span class="line">        public Node left;</span><br><span class="line">        //右子节点</span><br><span class="line">        public Node right;</span><br><span class="line"></span><br><span class="line">        public Node(Key key, Value value, Node left, Node right) &#123;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void put(Key key, Value value) &#123;</span><br><span class="line">        root = put(root, key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Value get(Key key) &#123;</span><br><span class="line">        return get(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Value get(Node node, Key key) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int comp = key.compareTo(node.key);</span><br><span class="line">        if (comp &gt; 0) &#123;</span><br><span class="line">            return get(node.right, key);</span><br><span class="line">        &#125; else if (comp &lt; 0) &#123;</span><br><span class="line">            return get(node.left, key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return node.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node put(Node node, Key key, Value value) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            N++;</span><br><span class="line">            return new Node(key, value, null, null);</span><br><span class="line">        &#125;</span><br><span class="line">        int comp = key.compareTo(node.key);</span><br><span class="line">        if (comp &gt; 0) &#123;</span><br><span class="line">            //如果待插入的key比父节点大，继续往右边插入</span><br><span class="line">            node.right = put(node.right, key, value);</span><br><span class="line">        &#125; else if (comp &lt; 0) &#123;</span><br><span class="line">            //如果待插入的key比父节点小，继续往左边插入</span><br><span class="line">            node.left = put(node.left, key, value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void delete(Key key) &#123;</span><br><span class="line">        delete(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node delete(Node x, Key key) &#123;</span><br><span class="line">        if(x == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int comp = key.compareTo(x.key);</span><br><span class="line">        if (comp &gt; 0) &#123;</span><br><span class="line">            //如果待删除的key比父节点大</span><br><span class="line">            x.right = delete(x.right, key);</span><br><span class="line">        &#125; else if (comp &lt; 0) &#123;</span><br><span class="line">            //如果待删除的key比父节点小</span><br><span class="line">            x.left = delete(x.left, key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            if(x.right == null) &#123;</span><br><span class="line">                return x.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(x.left == null) &#123;</span><br><span class="line">                return x.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //找到右子树的最小节点</span><br><span class="line">            Node minNode = x.right;</span><br><span class="line">            while (minNode.left != null) &#123;</span><br><span class="line">                minNode = minNode.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //把最小节点的引用删除</span><br><span class="line">            Node n = x.right;</span><br><span class="line">            while (n.left != null) &#123;</span><br><span class="line">                if(n.left.left == null) &#123;</span><br><span class="line">                    n.left = null;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    n =n.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            minNode.left = x.left;</span><br><span class="line">            minNode.right = x.right;</span><br><span class="line">            x = minNode;</span><br><span class="line">        &#125;</span><br><span class="line">        N--;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//先访问根节点，然后再访问左子树，最后访问右子树</span><br><span class="line">public List&lt;Key&gt; preForeach() &#123;</span><br><span class="line">    List&lt;Key&gt; keys = new ArrayList&lt;&gt;();</span><br><span class="line">    preForeach(root, keys);</span><br><span class="line">    return keys;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void preForeach(Node x, List&lt;Key&gt; keys) &#123;</span><br><span class="line">    if(x == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //把x节点放到keys中</span><br><span class="line">    keys.add(x.key);</span><br><span class="line">    //递归遍历x节点的左子树</span><br><span class="line">    if(x.left != null) &#123;</span><br><span class="line">        preForeach(x.left, keys);</span><br><span class="line">    &#125;</span><br><span class="line">    //遍历x节点的右子树</span><br><span class="line">    if(x.right != null) &#123;</span><br><span class="line">        preForeach(x.right, keys);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//先访问左子树，中间访问根节点，最后访问右子树</span><br><span class="line">public List&lt;Key&gt; midForeach() &#123;</span><br><span class="line">    List&lt;Key&gt; keys = new ArrayList&lt;&gt;();</span><br><span class="line">    midForeach(root, keys);</span><br><span class="line">    return keys;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void midForeach(Node x, List&lt;Key&gt; keys) &#123;</span><br><span class="line">    if(x == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //递归遍历x节点的左子树</span><br><span class="line">    if(x.left != null) &#123;</span><br><span class="line">        midForeach(x.left, keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //把x节点放到keys中</span><br><span class="line">    keys.add(x.key);</span><br><span class="line"></span><br><span class="line">    //遍历x节点的右子树</span><br><span class="line">    if(x.right != null) &#123;</span><br><span class="line">        midForeach(x.right, keys);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//先访问左子树，再访问右子树，最后访问根节点</span><br><span class="line">public List&lt;Key&gt; afterForeach() &#123;</span><br><span class="line">    List&lt;Key&gt; keys = new ArrayList&lt;&gt;();</span><br><span class="line">    afterForeach(root, keys);</span><br><span class="line">    return keys;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void afterForeach(Node x, List&lt;Key&gt; keys) &#123;</span><br><span class="line">    if(x == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //递归遍历x节点的左子树</span><br><span class="line">    if(x.left != null) &#123;</span><br><span class="line">        afterForeach(x.left, keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历x节点的右子树</span><br><span class="line">    if(x.right != null) &#123;</span><br><span class="line">        afterForeach(x.right, keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //把x节点放到keys中</span><br><span class="line">    keys.add(x.key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//层序遍历，新建一个队列，每次从队列中弹出一个节点存到keys中，如果存在子节点，就将子节点添加到该队列</span><br><span class="line">public List&lt;Key&gt; layerForeach() &#123;</span><br><span class="line">    List&lt;Key&gt; keys = new ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;Node&gt; nodes = new ArrayDeque&lt;&gt;();</span><br><span class="line">    nodes.offer(root);</span><br><span class="line">    while (!nodes.isEmpty()) &#123;</span><br><span class="line">        Node node = nodes.poll();</span><br><span class="line">        //判断是否存在左子节点</span><br><span class="line">        if(node.left != null) &#123;</span><br><span class="line">            nodes.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.right != null) &#123;</span><br><span class="line">            nodes.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        keys.add(node.key);</span><br><span class="line">    &#125;</span><br><span class="line">    return keys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大深度"><a href="#最大深度" class="headerlink" title="最大深度"></a>最大深度</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//获取整个树的最大深度</span><br><span class="line">public int maxDepth() &#123;</span><br><span class="line">    return maxDepth(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取指定数的最大深度</span><br><span class="line">private int maxDepth(Node node) &#123;</span><br><span class="line">    if(node == null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int leftDepth = 0, rightDepth = 0;</span><br><span class="line">    if(node.left != null) &#123;</span><br><span class="line">        leftDepth = maxDepth(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">    if(node.right != null) &#123;</span><br><span class="line">        rightDepth = maxDepth(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    return 1 + Math.max(leftDepth, rightDepth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>try-with-resources和try-catch</title>
      <link href="/blog/2022/10/28/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%92%8C%E9%87%8D%E6%9E%84/try-catch/"/>
      <url>/blog/2022/10/28/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%92%8C%E9%87%8D%E6%9E%84/try-catch/</url>
      
        <content type="html"><![CDATA[<h2 id="看下面这个例子，如果在finally直接抛出异常会将try块的异常忽略，但是在实际中，我们可能更关心try块的异常"><a href="#看下面这个例子，如果在finally直接抛出异常会将try块的异常忽略，但是在实际中，我们可能更关心try块的异常" class="headerlink" title="看下面这个例子，如果在finally直接抛出异常会将try块的异常忽略，但是在实际中，我们可能更关心try块的异常"></a>看下面这个例子，如果在finally直接抛出异常会将try块的异常忽略，但是在实际中，我们可能更关心try块的异常</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    throw new RuntimeException(&quot;1&quot;);</span><br><span class="line">&#125; catch(RuntimeException e) &#123;</span><br><span class="line">    throw new CustomerException(&quot;2&quot;);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    throw new NullPointerException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line">at com.cc.expection.Exception.main(Exception.java:25)</span><br></pre></td></tr></table></figure><h2 id="在finally捕获抛出的异常，并通过addSuppressed将异常附加到try块的异常中"><a href="#在finally捕获抛出的异常，并通过addSuppressed将异常附加到try块的异常中" class="headerlink" title="在finally捕获抛出的异常，并通过addSuppressed将异常附加到try块的异常中"></a>在finally捕获抛出的异常，并通过addSuppressed将异常附加到try块的异常中</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Throwable throwable = null;</span><br><span class="line">try &#123;</span><br><span class="line">    throw new RuntimeException(&quot;1&quot;);</span><br><span class="line">&#125; catch(RuntimeException e) &#123;</span><br><span class="line">    throwable = new CustomerException(&quot;2&quot;);</span><br><span class="line">    throw throwable;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125; catch (NullPointerException exception) &#123;</span><br><span class="line">        throwable.addSuppressed(exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">Exception in thread &quot;main&quot; com.cc.expection.CustomerException: 2</span><br><span class="line">at com.cc.expection.Exception.main(Exception.java:31)</span><br><span class="line">Suppressed: java.lang.NullPointerException</span><br><span class="line">at com.cc.expection.Exception.main(Exception.java:35)</span><br></pre></td></tr></table></figure><h2 id="使用try-with-resources"><a href="#使用try-with-resources" class="headerlink" title="使用try-with-resources"></a>使用try-with-resources</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//模拟关闭流的时候抛出异常</span><br><span class="line">class MyStream implements AutoCloseable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void close() throws java.lang.Exception &#123;</span><br><span class="line">        throw new CustomerException(&quot;close error...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try(MyStream stream = new MyStream()) &#123;</span><br><span class="line">    throw new RuntimeException(&quot;1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: 1</span><br><span class="line">at com.cc.expection.Exception.main(Exception.java:43)</span><br><span class="line">Suppressed: com.cc.expection.CustomerException: close error...</span><br><span class="line">at com.cc.expection.MyStream.close(Exception.java:51)</span><br><span class="line">at com.cc.expection.Exception.main(Exception.java:42)</span><br></pre></td></tr></table></figure><blockquote><p>可以看到try-with-resources对比try-catch简洁了许多</p></blockquote><h2 id="查看try-with-resources编译后的文件发现finally的异常也是通过addSuppressed方法附加到try块的异常中"><a href="#查看try-with-resources编译后的文件发现finally的异常也是通过addSuppressed方法附加到try块的异常中" class="headerlink" title="查看try-with-resources编译后的文件发现finally的异常也是通过addSuppressed方法附加到try块的异常中"></a>查看try-with-resources编译后的文件发现finally的异常也是通过addSuppressed方法附加到try块的异常中</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MyStream var1 = new MyStream();</span><br><span class="line">Throwable var2 = null;</span><br><span class="line">try &#123;</span><br><span class="line">    throw new RuntimeException(&quot;1&quot;);</span><br><span class="line">&#125; catch (Throwable var10) &#123;</span><br><span class="line">    var2 = var10;</span><br><span class="line">    throw var10;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    if (var1 != null) &#123;</span><br><span class="line">        if (var2 != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                var1.close();</span><br><span class="line">            &#125; catch (Throwable var9) &#123;</span><br><span class="line">                var2.addSuppressed(var9);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var1.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码规范和重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范和重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式、代理模式、装饰者模式的区别</title>
      <link href="/blog/2022/10/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E3%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E3%80%81%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/blog/2022/10/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E3%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E3%80%81%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这三个模式都是在辅助类中持有一个目标类的对象，通过操作这个目标对象，完成具体业务。</p></blockquote><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote><p>定义某个接口，以不同的实现类来代替实现某种功能。</p></blockquote><p><code>例如选择出行方式，我可以选择飞机、火车、汽车，出行方式就是某种策略，具体的交通工具就是具体功能。</code></p><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><blockquote><p>定义不同的装饰类，这些装饰类都是核心类的子类，可以为该核心类动态添加不同的功能模块。</p></blockquote><p><code>在不修改核心类功能的情况下，添加额外的功能。</code></p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote><p>将某个具体类包装起来，通过代理类来处理消费方和生产方之间的交互。</p></blockquote><p><code>例如日志收集，客户只想知道核心功能，无需感知是否进行了日志收集。</code></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式（三）观察者模式</title>
      <link href="/blog/2022/10/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2022/10/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="一、观察者模式"><a href="#一、观察者模式" class="headerlink" title="一、观察者模式"></a>一、观察者模式</h1><blockquote><p>当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//观察者接口（jdk自带）</span><br><span class="line">public interface Observer &#123;</span><br><span class="line">//收到通知</span><br><span class="line">    void update(Observable o, Object arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//观察者</span><br><span class="line">class ObserverOne implements Observer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void update(Observable o, Object arg) &#123;</span><br><span class="line">        //收到通知</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//主题（jdk自带）</span><br><span class="line">public class Observable &#123;</span><br><span class="line">    //添加观察者</span><br><span class="line">    void add(Observer observer);</span><br><span class="line">    //删除观察者</span><br><span class="line">    void remove(Observer observer);</span><br><span class="line">    //通知所有观察者</span><br><span class="line">    void notifyObservers();</span><br><span class="line">&#125;</span><br><span class="line">//被观察者</span><br><span class="line">class Subject extends Observable &#123;</span><br><span class="line"></span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        //发生改变</span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers(&quot;通知...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Subject subject = new Subject();</span><br><span class="line">    ObserverOne ob = new ObserverOne();</span><br><span class="line">    //添加观察者</span><br><span class="line">    subject.addObserver(ob);</span><br><span class="line">    //执行业务逻辑后，通知观察者</span><br><span class="line">    subject.doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Union-Find算法</title>
      <link href="/blog/2022/10/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/Union-Find/"/>
      <url>/blog/2022/10/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/Union-Find/</url>
      
        <content type="html"><![CDATA[<h1 id="动态连通性"><a href="#动态连通性" class="headerlink" title="动态连通性"></a>动态连通性</h1><blockquote><p>输入一个整数对p,q 如果不连通则将其相连并打印，反之则跳过<br>「连通」是一种等价关系，也就是说具有如下三个性质：<br>1、自反性：节点p和p是连通的。<br>2、对称性：如果节点p和q连通，那么q和p也连通。<br>3、传递性：如果节点p和q连通，q和r连通，那么p和r也连通。</p></blockquote><blockquote><p>动态连通性其实可以抽象成给一幅图连线。比如下面这幅图，总共有 10 个节点，他们互不相连，分别用 0~9 标记：<br><img src="/blog/img/md/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/unionFind01.png"></p></blockquote><blockquote><p>0～9 任意两个不同的点都不连通，调用connected都会返回 false，连通分量为 10 个。<br>如果现在调用union(0, 1)，那么 0 和 1 被连通，连通分量降为 9 个。<br>再调用union(1, 2)，这时 0,1,2 都被连通，调用connected(0, 2)也会返回 true，连通分量变为 8 个。</p></blockquote><p><img src="/blog/img/md/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/unionFind02.png"></p><h2 id="代码实现（quick-find）"><a href="#代码实现（quick-find）" class="headerlink" title="代码实现（quick-find）"></a>代码实现（quick-find）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class UnionFind &#123;</span><br><span class="line">    //分量id（以触点作为索引）</span><br><span class="line">    private int[] id;</span><br><span class="line">    //分量数量</span><br><span class="line">    private int count;</span><br><span class="line"></span><br><span class="line">    public UnionFind(int N) &#123;</span><br><span class="line">        count = N;</span><br><span class="line">        id = new int[N];</span><br><span class="line">        for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void union(int p, int q) &#123;</span><br><span class="line">        //将p和q归并到相同分量</span><br><span class="line">        int pID = find(p);</span><br><span class="line">        int qID = find(q);</span><br><span class="line">        //如果p和q已经在相同分量之中</span><br><span class="line">        if(pID == qID) return;</span><br><span class="line"></span><br><span class="line">        //将p的分量重命名为q的名称</span><br><span class="line">        for (int i = 0; i &lt; id.length; i++) &#123;</span><br><span class="line">            if(id[i] == pID) id[i] = qID;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int find(int p) &#123;</span><br><span class="line">        return id[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean connected(int p, int q) &#123;</span><br><span class="line">        return find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int N = StdIn.readInt(); //读取触点数量</span><br><span class="line">        UnionFind uf = new UnionFind(N); //初始化N个分量</span><br><span class="line">        while (!StdIn.isEmpty()) &#123;</span><br><span class="line">            int p = StdIn.readInt();</span><br><span class="line">            int q = StdIn.readInt(); //读取整数对</span><br><span class="line">            if(uf.connected(p, q)) continue; //如果已经连通则忽略</span><br><span class="line">            uf.union(p, q); //归并分量</span><br><span class="line">            System.out.println(&quot;连接:&quot; + p + &quot; &quot; + q); //打印连接</span><br><span class="line">            System.out.println(Arrays.toString(uf.id));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(uf.count + &quot;components&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>find()操作速度是很快，但是union算法是平方级的，对每一次输入union都需要扫描整个id[]数组</p></blockquote><h2 id="quick-union"><a href="#quick-union" class="headerlink" title="quick-union"></a>quick-union</h2><blockquote><p>如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上</p></blockquote><p><img src="/blog/img/md/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/unionFind03.png"></p><h3 id="代码实现（quick-union）"><a href="#代码实现（quick-union）" class="headerlink" title="代码实现（quick-union）"></a>代码实现（quick-union）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//quick-union实现</span><br><span class="line">public void union(int p, int q) &#123;</span><br><span class="line">    //将p和q的根节点统一</span><br><span class="line">    int pRoot = find(p);</span><br><span class="line">    int qRoot = find(q);</span><br><span class="line">    //如果p和q已经在相同分量之中</span><br><span class="line">    if(pRoot == qRoot) return;</span><br><span class="line"></span><br><span class="line">    //将p的根节点重命名为q的名称</span><br><span class="line">    id[pRoot] = qRoot;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br><span class="line">public int find(int p) &#123;</span><br><span class="line">    //找到根节点</span><br><span class="line">    while (p != id[p]) p = id[p];</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加权quick-union算法"><a href="#加权quick-union算法" class="headerlink" title="加权quick-union算法"></a>加权quick-union算法</h2><blockquote><p>上面的算法最坏情况会导致树变成链表，为了让树能够平衡，只需要简单修改quick-union就能保证这样的情况不会出现，在union()中<br>随意将一棵树连接到另一棵树，我们现在记录每一棵树的大小并总是将较小的树连接到较大的树上。</p></blockquote><p>##代码实现（加权quick-union）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//分量id（以触点作为索引）</span><br><span class="line">private int[] id;</span><br><span class="line">//树的深度</span><br><span class="line">private int[] sz;</span><br><span class="line">//分量数量</span><br><span class="line">private int count;</span><br><span class="line"></span><br><span class="line">public WeightedUnionFind(int N) &#123;</span><br><span class="line">    count = N;</span><br><span class="line">    id = new int[N];</span><br><span class="line">    sz = new int[N];</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        sz[i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//quick-union实现</span><br><span class="line">public void union(int p, int q) &#123;</span><br><span class="line">    //将p和q的根节点统一</span><br><span class="line">    int pRoot = find(p);</span><br><span class="line">    int qRoot = find(q);</span><br><span class="line">    //如果p和q已经在相同分量之中</span><br><span class="line">    if(pRoot == qRoot) return;</span><br><span class="line"></span><br><span class="line">    //将小树的根节点连接到大树的根节点</span><br><span class="line">    if(sz[pRoot] &lt; sz[qRoot]) &#123;</span><br><span class="line">        id[pRoot] = qRoot;</span><br><span class="line">        sz[qRoot] += sz[pRoot];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        id[qRoot] = pRoot;</span><br><span class="line">        sz[pRoot] += sz[qRoot];</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归纳法</title>
      <link href="/blog/2022/10/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%BD%92%E7%BA%B3%E6%B3%95/"/>
      <url>/blog/2022/10/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%BD%92%E7%BA%B3%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>证明当n= 1时命题成立。<br>假设n=m时命题成立，那么可以推导出在n=m+1时命题也成立。</p></blockquote><h1 id="证明从N个数中取三个整数的不同组合为-N-N-1-N-2-6"><a href="#证明从N个数中取三个整数的不同组合为-N-N-1-N-2-6" class="headerlink" title="证明从N个数中取三个整数的不同组合为 N(N-1)(N-2)/6"></a>证明从N个数中取三个整数的不同组合为 N(N-1)(N-2)/6</h1><blockquote><p>从N+1个整数中取出3个整数的不同组合的总数可以分成两部分<br>第一部分:不包含第N+1元素的,有f(N)=N(N-1)(N-2)/6<br>第二部分:包含第N+1元素的,即从N个数中取两个整数的总和为N(N-1)/2<br>只要求证f(N+1) = f(N) + N(N-1)/2即可</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/blog/2022/10/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/blog/2022/10/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从数组的中间元素开始搜索，如果该元素正好是目标元素，则搜索过程结束，否则执行下一步。<br>如果目标元素大于/小于中间元素，则在数组大于/小于中间元素的那一半区域查找，然后重复步骤（1）的操作。<br>如果某一步数组为空，则表示找不到目标元素。<br>二分法查找的时间复杂度O(logn)。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class BinarySearch &#123;</span><br><span class="line"></span><br><span class="line">    //递归查询</span><br><span class="line">    public static int recursiveSearch(int key, int[] arr, int low, int high) &#123;</span><br><span class="line">        if(low &lt;= high) &#123;</span><br><span class="line">            int mid = low + (high - low) / 2;</span><br><span class="line">            if (key == arr[mid]) &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125; else if (key &gt; arr[mid]) &#123;</span><br><span class="line">                return recursiveSearch(key, arr, mid + 1, high);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return recursiveSearch(key, arr, low, mid - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //非递归查询</span><br><span class="line">    public static int search(int key, int[] arr) &#123;</span><br><span class="line">        int low = 0;</span><br><span class="line">        int high = arr.length - 1;</span><br><span class="line">        while (low &lt;= high) &#123;</span><br><span class="line">            int mid = low + (high - low) / 2;</span><br><span class="line">            if (key == arr[mid]) &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125; else if (key &gt; arr[mid]) &#123;</span><br><span class="line">                low = mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                high = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;</span><br><span class="line">        System.out.println(search(2, arr));</span><br><span class="line">        System.out.println(recursiveSearch(7, arr, 0 , arr.length - 1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式（二）策略模式</title>
      <link href="/blog/2022/10/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2022/10/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="一、策略模式"><a href="#一、策略模式" class="headerlink" title="一、策略模式"></a>一、策略模式</h1><blockquote><p>定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">//出行策略</span><br><span class="line">interface TravelStrategy &#123;</span><br><span class="line">    void go();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//坐飞机出门</span><br><span class="line">class AirPlaneStrategy implements TravelStrategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void go() &#123;</span><br><span class="line">        System.out.println(&quot;坐飞机出门...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//坐火车出门</span><br><span class="line">class TrainStrategy implements TravelStrategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void go() &#123;</span><br><span class="line">        System.out.println(&quot;坐火车出门...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//出行</span><br><span class="line">class Travel &#123;</span><br><span class="line">    //出行方式</span><br><span class="line">    private TravelStrategy travelStrategy;</span><br><span class="line"></span><br><span class="line">    public Travel() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Travel(TravelStrategy travelStrategy) &#123;</span><br><span class="line">        this.travelStrategy = travelStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTravelStrategy(TravelStrategy travelStrategy) &#123;</span><br><span class="line">        this.travelStrategy = travelStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //开始旅行</span><br><span class="line">    public void startTravel() &#123;</span><br><span class="line">        travelStrategy.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Strategy &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //坐火车出行</span><br><span class="line">        Travel travel = new Travel(new TrainStrategy());</span><br><span class="line">        travel.startTravel();</span><br><span class="line">        //改变策略，坐飞机出门</span><br><span class="line">        travel.setTravelStrategy(new AirPlaneStrategy());</span><br><span class="line">        travel.startTravel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NacosConfigurationProperties注解修改了final修饰的成员变量</title>
      <link href="/blog/2022/10/21/bug/final%E4%BF%AE%E9%A5%B0%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E8%A2%AB%E4%BF%AE%E6%94%B9/"/>
      <url>/blog/2022/10/21/bug/final%E4%BF%AE%E9%A5%B0%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E8%A2%AB%E4%BF%AE%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><blockquote><p>nacos-config-spring-boot-starter: 0.2.11</p></blockquote><h2 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@NacosConfigurationProperties</span><br><span class="line">public class BusinessProperties &#123;</span><br><span class="line">    //声明了一个final的成员变量</span><br><span class="line">    private final ConcurrentMap&lt;String, Map&lt;String, MsgConfigDto&gt;&gt; propertyWarnConfig = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    ...</span><br><span class="line">    public Map&lt;String, Map&lt;String, MsgConfigDto&gt;&gt; getPropertyWarnConfig() &#123;</span><br><span class="line">        return propertyWarnConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用的时候，属性变为null了</span><br><span class="line">businessProperties.getPropertyWarnConfig() =&gt; null</span><br></pre></td></tr></table></figure><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><blockquote><p>调用链路 =&gt; NacosConfigurationPropertiesBindingPostProcessor#bind =&gt; NacosConfigurationPropertiesBinder#bind<br>=&gt; NacosBootConfigurationPropertiesBinder#doBind （ObjectUtils.cleanMapOrCollectionField(bean);）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//通过反射将集合的成员变量设为null</span><br><span class="line">ReflectionUtils.doWithFields(bean.getClass(),</span><br><span class="line">    new ReflectionUtils.FieldCallback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void doWith(Field field)</span><br><span class="line">                throws IllegalArgumentException, IllegalAccessException &#123;</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            if (field.isAnnotationPresent(NacosIgnore.class)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            Class&lt;?&gt; type = field.getType();</span><br><span class="line"></span><br><span class="line">            if (Map.class.isAssignableFrom(type)</span><br><span class="line">                    || Collection.class.isAssignableFrom(type)) &#123;</span><br><span class="line">                field.set(bean, null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><blockquote><p>在不需要被修改的成员变量上加上@NacosIgnore注解</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/blog/2022/10/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/blog/2022/10/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>执行主函数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Random random = new Random();</span><br><span class="line">List&lt;String&gt; sortMethod = Arrays.asList(&quot;maoPaoSort&quot;, &quot;xuanzeSort&quot;, &quot;insertSort&quot;, &quot;xierSort&quot;, &quot;guibinSort&quot;);</span><br><span class="line">int[] sourceArr = new int[10000];</span><br><span class="line">for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">    //随机</span><br><span class="line">//  sourceArr[i] = random.nextInt(1000000);</span><br><span class="line">    //完全逆序</span><br><span class="line">    sourceArr[i] = 10000 - i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;排序前：&quot; + Arrays.toString(sourceArr));</span><br><span class="line">for (String method : sortMethod) &#123;</span><br><span class="line">    int[] arr = sourceArr.clone();</span><br><span class="line">    long startTime = System.currentTimeMillis();</span><br><span class="line">    Object result = SortTest.class.getMethod(method, int[].class).invoke(null, arr);</span><br><span class="line">    if(result instanceof int[]) &#123;</span><br><span class="line">        arr = (int[]) result;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;执行时间&quot; + (System.currentTimeMillis() - startTime) + &quot;毫秒&quot;);</span><br><span class="line">    System.out.println(method + &quot;排序后：&quot; + Arrays.toString(arr));</span><br><span class="line">    System.out.println(&quot;-------------------------------------------------------------------------------&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><blockquote><p>比较相邻的元素，如果前一个元素比后一个元素大，就交换这两个元素的位置。<br>对每一个相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。最终最后位置的元素就是最大值。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int [] arr = &#123;1, 3, 2, 6, 5, 4&#125;;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    for (int j = 1; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">        int temp = arr[j];</span><br><span class="line">        if(temp &lt; arr[j - 1]) &#123;</span><br><span class="line">            arr[j] = arr[j - 1];</span><br><span class="line">            arr[j - 1] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><blockquote><p>每次循环找到最小的元素放在前面</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">    int minIndex = i;</span><br><span class="line">    for (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">        if(arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">            minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int temp = arr[i];</span><br><span class="line">    arr[i] = arr[minIndex];</span><br><span class="line">    arr[minIndex] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote><p>把一个数组分为两部分，一边是已排序部分，一边是未排序部分，遍历未排序部分，向已排序部分插入元素</p></blockquote><p><img src="/blog/img/md/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/insertionSort.gif"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= arr.length - 1; i++) &#123;</span><br><span class="line">    int temp = arr[i]; //需要交换的原数据</span><br><span class="line">    for (int j = i - 1; j &gt;= 0; j--) &#123; //遍历已排序数组</span><br><span class="line">        //如果比前面的数小，就交换位置</span><br><span class="line">        if (temp &lt; arr[j]) &#123;</span><br><span class="line">            arr[j + 1] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125; else &#123; //再前一个数字比原数据大了，不需要继续交换了</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="希尔排序（插入排序的优化）"><a href="#希尔排序（插入排序的优化）" class="headerlink" title="希尔排序（插入排序的优化）"></a>希尔排序（插入排序的优化）</h1><blockquote><p>选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组<br>对分好组的数据完成插入排序<br>减小增长量，最小减为1，重复第二步操作</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for (int h = arr.length / 2; h &gt;= 1; h /= 2) &#123; // h为增量</span><br><span class="line">    for (int i = h; i &lt; arr.length; i++) &#123;</span><br><span class="line">        int temp = arr[i]; //需要交换的原数据</span><br><span class="line">        for (int j = i - h; j &gt;= 0; j -= h) &#123; //遍历已排序数组</span><br><span class="line">            //如果比前面的数小，就交换位置</span><br><span class="line">            if(temp &lt; arr[j]) &#123;</span><br><span class="line">                arr[j + h] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break; //再前一个数字比原数据大了，不需要继续交换了</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><img src="/blog/img/md/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/guibinSort.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static int[] guibinSort(int[] arr) &#123;</span><br><span class="line">    if(arr.length &lt; 2) &#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    //分成两个数组</span><br><span class="line">    int middle = arr.length / 2;</span><br><span class="line">    int[] leftArr = Arrays.copyOfRange(arr, 0, middle);</span><br><span class="line">    int[] rightArr = Arrays.copyOfRange(arr, middle, arr.length);</span><br><span class="line">    return merge(guibinSort(leftArr), guibinSort(rightArr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int[] merge(int[] leftArr, int[] rightArr) &#123;</span><br><span class="line">    int[] result = new int[leftArr.length + rightArr.length];</span><br><span class="line">    int leftIndex = 0, rightIndex = 0;</span><br><span class="line">    int resultIndex = 0;</span><br><span class="line">    while (leftIndex &lt; leftArr.length &amp;&amp; rightIndex &lt; rightArr.length) &#123;</span><br><span class="line">        if(leftArr[leftIndex] &lt; rightArr[rightIndex]) &#123;</span><br><span class="line">            result[resultIndex++] = leftArr[leftIndex++];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result[resultIndex++] = rightArr[rightIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (leftIndex &lt; leftArr.length) &#123;</span><br><span class="line">        result[resultIndex++] = leftArr[leftIndex++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (rightIndex &lt; rightArr.length) &#123;</span><br><span class="line">        result[resultIndex++] = rightArr[rightIndex++];</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><blockquote><p>从数列中挑出一个元素，称为 “基准”（pivot）;<br>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p></blockquote><p><img src="/blog/img/md/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/quickSort.gif"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void quickSort(int[] arr) &#123;</span><br><span class="line">    doQuickSort(arr, 0, arr.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void doQuickSort(int[] arr, int startIndex, int endIndex) &#123;</span><br><span class="line">    if (startIndex &lt; endIndex) &#123;</span><br><span class="line">        int begin = startIndex, end = endIndex;</span><br><span class="line">        int baseValue = arr[startIndex]; //基准值</span><br><span class="line">        while (begin != end) &#123;</span><br><span class="line">            //先从右往左找小于基准值的数，再从左往右找大于基准值的数</span><br><span class="line">            while (arr[end] &gt;= baseValue &amp;&amp; begin &lt; end) &#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">            while (arr[begin] &lt;= baseValue &amp;&amp; begin &lt; end) &#123;</span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(end &gt; begin) &#123;</span><br><span class="line">                int temp = arr[begin];</span><br><span class="line">                arr[begin] = arr[end];</span><br><span class="line">                arr[end] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[startIndex] = arr[begin];</span><br><span class="line">        arr[begin] = baseValue;</span><br><span class="line">        doQuickSort(arr, startIndex, begin - 1);</span><br><span class="line">        doQuickSort(arr, begin + 1, endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/blog/2022/10/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/blog/2022/10/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="青蛙跳台"><a href="#青蛙跳台" class="headerlink" title="青蛙跳台"></a>青蛙跳台</h2><blockquote><p>一只青蛙每次可以跳1个或2个台阶，那么要上到第n个台阶上一共有多少种跳法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static int jump(int i) &#123;</span><br><span class="line">    if (i == 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else if (i == 2) &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125; else if (i &lt;= 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return jump(i - 2) + jump(i - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存模型</title>
      <link href="/blog/2022/10/17/JVM/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/blog/2022/10/17/JVM/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p><img src="/blog/img/md/JVM/heapModel.jpg"></p><h2 id="程序计数器（线程私有）"><a href="#程序计数器（线程私有）" class="headerlink" title="程序计数器（线程私有）"></a>程序计数器（线程私有）</h2><blockquote><p>内存占用很小，几乎可以忽略不计（无OOM）<br>存储当前线程所执行的字节码行号。当cpu时间片被其他线程占用后，<br>这个线程将被挂起，当这个线程重新被唤醒的时候需要知道从哪个地方开始执行。</p></blockquote><h2 id="虚拟机栈（线程私有）"><a href="#虚拟机栈（线程私有）" class="headerlink" title="虚拟机栈（线程私有）"></a>虚拟机栈（线程私有）</h2><blockquote><p>每当有方法执行的时候，会创建一个栈帧存到虚拟机栈里<br>当栈的深度大于虚拟机允许的深度，会抛出StackOverflowError异常（方法递归调用）<br>如果虚拟机栈无法申请到足够的内存，还会抛出OutOfMemoryError异常（循环创建线程导致栈内存不足无法分配）</p></blockquote><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><ul><li><p>局部变量表</p><blockquote><p>包含了方法的局部变量，8种基本数据类型，对象引用，returnAddress类型</p></blockquote></li><li><p>操作数栈</p><blockquote><p>根据字节码指令压入操作数栈，再通过指令将操作数取出</p></blockquote></li><li><p>动态链接</p><blockquote><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用</p></blockquote></li><li><p>方法出口</p></li></ul><h2 id="本地方法栈（线程私有）"><a href="#本地方法栈（线程私有）" class="headerlink" title="本地方法栈（线程私有）"></a>本地方法栈（线程私有）</h2><blockquote><p>与虚拟机栈一样，只是方法类型不同</p></blockquote><h2 id="堆（线程共享）"><a href="#堆（线程共享）" class="headerlink" title="堆（线程共享）"></a>堆（线程共享）</h2><blockquote><p>占用内存最大的一块，存放对象实例，垃圾回收的主要区域<br>堆空间 = 新生代1/3（Eden8/10 + From Survivor1/10 + ToSurvivor1/10） + 老年代2/3<br>堆大小可以通过参数–Xms（堆的初始容量）、-Xmx（堆的最大容量）指定<br>GC分为两种： Minor GC、Full GC</p></blockquote><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><blockquote><p>GS Roots根节点：线程栈的本地变量，静态变量，本地方法栈的变量等等<br>将GS Roots对象作为起点，找到引用的对象并标记为非垃圾，其余都是垃圾对象</p></blockquote><h2 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h2><blockquote><p> 当对象不断生成的时候，会先进入Eden，当Eden放不下了，触发Minor GC，<br>将存活的对象转移到from区，当Eden和from区都放不下后，触发Minor GC，将仍存活的对象复制到to区，然后清理Eden和from区，并<br>将这些对象年龄设为1，以后每次Minor GC对象年龄都会加1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )<br>这些对象就会成为老年代<br>如果对象较大则直接进入到老年代</p></blockquote><h2 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h2><blockquote><p>STW（stop the world）：暂停所有的用户线程（防止在GC的时候，用户线程执行完毕产生新的垃圾）<br>大对象直接进入老年代，动态年龄判断，年龄大于阈值，进入老年代，Minor GC后，存活的对象空间大于survivor空间，直接进入老年代</p></blockquote><blockquote><p>动态年龄判断：如果Survivor空间中相同年龄的对象（年龄1+年龄2+年龄3+年龄N）总和大小大于Survivor总容量的一半，年龄大于或等于该年龄的对象就可以直接进入老年代</p></blockquote><h2 id="方法区-元空间（内存共享）"><a href="#方法区-元空间（内存共享）" class="headerlink" title="方法区/元空间（内存共享）"></a>方法区/元空间（内存共享）</h2><blockquote><p>存储已加载的类信息、常量、静态变量、即时编译器编译后的代码等<br>Class文件常量池、运行时常量池<br>常量池存的是字面量（字符串、被声明为final的常量值、基本数据类型）<br>符号引用（各类包、类、接口、字段、方法等元素的全限定名），在类加载连接过程中的解析会把符号引用替换为直接引用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载</title>
      <link href="/blog/2022/10/17/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
      <url>/blog/2022/10/17/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><blockquote><p>Java程序在计算机中的三个阶段</p></blockquote><p><img src="/blog/img/md/JVM/classLoder01.png"></p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><blockquote><p>类加载的五个阶段<br><img src="/blog/img/md/JVM/classLoder02.png"></p></blockquote><ol><li><p>加载阶段</p><blockquote><p>JVM从不同的数据源加载的字节码文件转化为二进制字节流加载到内存中，并生成一个代表该类的Class对象</p></blockquote></li><li><p>连接阶段</p></li></ol><ul><li><p>验证</p><blockquote><p>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，且不会危害虚拟机自身的安全。</p></blockquote></li><li><p>准备</p><blockquote><p>JVM在该阶段对静态变量，分配内存并默认初始化，这些变量的内存都在方法区进行分配。</p></blockquote></li><li><p>解析</p><blockquote><p>将符号引用解析为直接引用，在一个字节码文件中，会用到其他类，而在字节码中只会存用到的类的类名，而解析阶段就是会根据类名找到<br>该类加载后在方法区中的地址，也就是直接引用，并替换调符号引用，这样真正运行字节码时，就能直接找到某个类了。</p></blockquote></li></ul><ol start="3"><li>初始化<blockquote><p>收集所有静态变量和静态代码块中的语句，合并后进行赋值。</p></blockquote></li></ol><h2 id="什么是类加载器"><a href="#什么是类加载器" class="headerlink" title="什么是类加载器"></a>什么是类加载器</h2><blockquote><p>在类加载阶段，类加载器会将字节码文件转化为二进制字节流加载到内存中</p></blockquote><h2 id="为什么有那么多类加载器"><a href="#为什么有那么多类加载器" class="headerlink" title="为什么有那么多类加载器"></a>为什么有那么多类加载器</h2><ol><li>需要从多种来源读取字节流，例如网络、文件系统等</li><li>相同包下的两个类A（methodA()包访问）、B（methodB()包访问），只有都有同一个类加载器加载时A才有对B的package访问权限。<br>如果两个类的类加载器不同，A类就无法访问B类的methodB方法，即使它们在同一个包下<h2 id="什么时候需要自定义类加载器"><a href="#什么时候需要自定义类加载器" class="headerlink" title="什么时候需要自定义类加载器"></a>什么时候需要自定义类加载器</h2></li><li>如果需要将编译后的代码用某种算法加密，可以自己实现类加载器，负责将这段代码加密后还原</li><li>需要自定义类的来源</li></ol><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><blockquote><p>当一个类需要被加载的时候，需要先把请求交给父类加载器，当父类加载器无法加载的时候，子类加载器才会去尝试加载。</p></blockquote><p><img src="/blog/img/md/%E9%9D%A2%E8%AF%95%E9%A2%98/01.png"></p><h3 id="为什么有双亲委派模型"><a href="#为什么有双亲委派模型" class="headerlink" title="为什么有双亲委派模型"></a>为什么有双亲委派模型</h3><blockquote><p>为了确保类只会被加载一次，如果我直接重写了Object类，没有双亲委派的话，就直接生效了。<br>有了双亲委派，这个类先被Bootstrap类加载器加载后，自己重写的类将不会生效。</p></blockquote><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class MyClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    private final String path;</span><br><span class="line"></span><br><span class="line">    public MyClassLoader(String path) &#123;</span><br><span class="line">        this.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        String classPath = path + name + &quot;.class&quot;;</span><br><span class="line">        try (InputStream inputStream = new FileInputStream(classPath);</span><br><span class="line">             ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) &#123;</span><br><span class="line">            int temp;</span><br><span class="line">            while ((temp = inputStream.read()) != -1) &#123;</span><br><span class="line">                outputStream.write(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            byte[] bytes = outputStream.toByteArray();</span><br><span class="line">            return defineClass(name, bytes, 0, bytes.length);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        throw new ClassNotFoundException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">   MyClassLoader classLoader = new MyClassLoader(&quot;D:\\classLoaderTest\\&quot;);</span><br><span class="line">   Class&lt;?&gt; clazz = classLoader.loadClass(&quot;HelloWorld&quot;);</span><br><span class="line">   System.out.println(clazz.getClassLoader());</span><br><span class="line">   System.out.println(clazz.getConstructor().newInstance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射机制</title>
      <link href="/blog/2022/10/17/Java/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
      <url>/blog/2022/10/17/Java/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h1><p>在java运行期间，通过反射api可以获取到任何类的内部信息（包括成员变量，构造器，成员方法等等），并可以操作对象的属性和方法。</p><h1 id="反射的原理"><a href="#反射的原理" class="headerlink" title="反射的原理"></a>反射的原理</h1><p>Java程序在计算机中有三个阶段:编译，加载，运行。当一个对象被实例化的时候，会加载一个Class类对象（仅会被加载一次）和当前对象。<br>这个Class类对象包含了完整的Class结构信息。</p><h1 id="什么时候需要反射"><a href="#什么时候需要反射" class="headerlink" title="什么时候需要反射"></a>什么时候需要反射</h1><ol><li>在Java运行时，假如有个A类，有methodA和methodB方法，如果我们要在不改变源码，从执行A方法改变为执行B方法，传统方式下无法完成，<br>通过反射，我们可以将A类的信息写在配置文件当中，如果需要从执行A方法修改为执行B方法，只需要修改配置文件，无需修改源码。</li><li>日志信息如果直接写在业务代码里，代码会显得很臃肿，我们可以通过反射获取这个类的代理对象，在代理方法前后写日志信息，这样就不会破坏源码结构</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码优化</title>
      <link href="/blog/2022/10/16/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%92%8C%E9%87%8D%E6%9E%84/EffectiveJava/"/>
      <url>/blog/2022/10/16/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%92%8C%E9%87%8D%E6%9E%84/EffectiveJava/</url>
      
        <content type="html"><![CDATA[<h2 id="1-遇到多个构造器参数时要考虑使用构造器"><a href="#1-遇到多个构造器参数时要考虑使用构造器" class="headerlink" title="1.遇到多个构造器参数时要考虑使用构造器"></a>1.遇到多个构造器参数时要考虑使用构造器</h2><blockquote><p>当你想要创建实例的时候，就利用参数列表最短的构造器，但该列表中包含了要设置的所有参数，通常需要许多你本不想设置的参数，但还是不得不为它们传递值。<br>简而言之，当有许多参数的时候，客户端代码会很难编写，并且仍然较难以阅读。</p></blockquote><p>使用建造者模式，让客户端利用所有必要的参数调用构造器得到一个builder对象。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class NutritionFacts &#123;</span><br><span class="line">    private final int servingSize;</span><br><span class="line">    private final int calories;</span><br><span class="line">    private final int fat;</span><br><span class="line"></span><br><span class="line">    private NutritionFacts(Builder builder) &#123;</span><br><span class="line">        this.servingSize = builder.servingSize;</span><br><span class="line">        this.calories = builder.calories;</span><br><span class="line">        this.fat = builder.fat;</span><br><span class="line">    &#125;</span><br><span class="line">    public static class Builder &#123;</span><br><span class="line">        //Required parameters</span><br><span class="line">        private final int servingSize;</span><br><span class="line"></span><br><span class="line">        //Optional parameters</span><br><span class="line">        private int calories = 0;</span><br><span class="line">        private int fat = 0;</span><br><span class="line"></span><br><span class="line">        public Builder(int servingSize) &#123;</span><br><span class="line">            this.servingSize = servingSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder calories(int val) &#123;</span><br><span class="line">            this.calories = val;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        public Builder fat(int val) &#123;</span><br><span class="line">            this.fat = val;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        public NutritionFacts builder() &#123;</span><br><span class="line">            return new NutritionFacts(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>lombok可以使用@Builder注解</p></blockquote><h2 id="2-避免创建不必要的对象"><a href="#2-避免创建不必要的对象" class="headerlink" title="2.避免创建不必要的对象"></a>2.避免创建不必要的对象</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//极端的例子（该语句每次执行都会创建一个新的String实例，如果在一个循环中，就会创建出成千上万不必要的String实例）</span><br><span class="line">String s = new String(&quot;bikini&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//有些对象创建的成本比其他对象要高很多，如果重复地需要这类对象，建议将它缓存下来重用。</span><br><span class="line">static boolean isRomanNumeral(String s) &#123;</span><br><span class="line">    return s.matches(&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span><br><span class="line">                + &quot;(x[CL]|L?X&#123;0,3&#125;(I[XV]|V?I&#123;0,3&#125;)$)&quot;);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//为了提升性能，应该显式地将正则表达式编译成一个Pattern实例，并缓存下来</span><br><span class="line">private static final Pattern ROMAN = Pattern.compile(&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span><br><span class="line">        + &quot;(x[CL]|L?X&#123;0,3&#125;(I[XV]|V?I&#123;0,3&#125;)$)&quot;);</span><br><span class="line"></span><br><span class="line">static boolean isRomanNumeral(String s) &#123;</span><br><span class="line">    return ROMAN.matcher(s).matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-要优先使用基本类型而不是包装基本类型，要当心无意识的自动装箱"><a href="#3-要优先使用基本类型而不是包装基本类型，要当心无意识的自动装箱" class="headerlink" title="3.要优先使用基本类型而不是包装基本类型，要当心无意识的自动装箱"></a>3.要优先使用基本类型而不是包装基本类型，要当心无意识的自动装箱</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//自动装箱使得基本类型和装箱基本类型之间的差别变得模糊起来，但是并没有完全消除</span><br><span class="line">private static long sum() &#123;</span><br><span class="line">    Long sum = 0L;</span><br><span class="line">    for (int i = 0; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">//这段代码的答案是正确的，但是比实际情况更慢一些，只因打错了一个字符。变量sum被声明成Long而不是long。</span><br><span class="line">//将sum的声明从Long改为long，在我的机器上使运行时间从6.3秒减少到了0.59秒</span><br></pre></td></tr></table></figure><h2 id="4-try-with-resources优先于try-finally"><a href="#4-try-with-resources优先于try-finally" class="headerlink" title="4.try-with-resources优先于try-finally"></a>4.try-with-resources优先于try-finally</h2><blockquote><p>在处理必须关闭的资源时，始终要优先考虑用try-with-resources，而不是用try-finally</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//根据经验，try-finally语句是确保资源会被适时关闭的最佳方法，就算发生异常或者返回也一样</span><br><span class="line">static String firstLineOfFile(String path) throws IOException &#123;</span><br><span class="line">    BufferedReader br = new BufferedReader(new FileReader(path));</span><br><span class="line">    try &#123;</span><br><span class="line">        return br.readLine();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//这样看起来好像不算太坏，但是如果再添加第二个资源，就会一团糟了</span><br><span class="line">static void copy(String src, String dst) throws IOException &#123;</span><br><span class="line">    InputStream in = new FileInputStream(src);</span><br><span class="line">    try &#123;</span><br><span class="line">        OutputStream out = new FileOutputStream(dst);</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] buf = new byte[BUFFER_SIZE];</span><br><span class="line">            int n;</span><br><span class="line">            while ((n = in.read(buf)) &gt;= 0) &#123;</span><br><span class="line">                out.write(buf, 0, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//即使用try-finally语句正确地关闭了资源，它也存在着些许不足。因为在try块和finally块中的代码，都会抛出异常</span><br><span class="line"></span><br><span class="line">//以下是使用try-with-resources的范例：</span><br><span class="line">try (BufferedReader br = new BufferedReader(new FileReader(path))) &#123;</span><br><span class="line">    return br.readLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void copy(String src, String dst) throws IOException &#123;</span><br><span class="line">    try (InputStream in = new FileInputStream(src);</span><br><span class="line">         OutputStream out = new FileOutputStream(dst)) &#123;</span><br><span class="line">        byte[] buf = new byte[BUFFER_SIZE];</span><br><span class="line">        int n;</span><br><span class="line">        while ((n = in.read(buf)) &gt;= 0) &#123;</span><br><span class="line">            out.write(buf, 0, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-使类和成员的可访问性最小化"><a href="#5-使类和成员的可访问性最小化" class="headerlink" title="5. 使类和成员的可访问性最小化"></a>5. 使类和成员的可访问性最小化</h2><blockquote><p>尽可能地使每个类或者成员不被外界访问</p></blockquote><h2 id="6-请不要使用原生态类型"><a href="#6-请不要使用原生态类型" class="headerlink" title="6.请不要使用原生态类型"></a>6.请不要使用原生态类型</h2><blockquote><p>出错应该尽快发现，最好是在编译时就发现</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//如果现在使用这条声明，并且不小心将一个coin放进了stamp集合中，这一错误的插入照样得以编译和运行，不会出错</span><br><span class="line">private final Collection stamps = ...;</span><br><span class="line">...</span><br><span class="line">stamps.add(new Coin());</span><br><span class="line"></span><br><span class="line">//直到从stamp集合中获取coin时才会收到一条错误提示</span><br><span class="line">for (Iterator i = stamps.iterator(); i.hasNext();) &#123;</span><br><span class="line">    Stamp stamp = (Stamp) i.next(); // Throws ClassCastException</span><br><span class="line">    stamp.cancel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用泛型后，编译器直到stamps只包含stamp实例，错误会在编译时产生</span><br><span class="line">private final Collection&lt;stamp&gt; stamps = ...;</span><br></pre></td></tr></table></figure><h2 id="7-用enum代替int常量"><a href="#7-用enum代替int常量" class="headerlink" title="7.用enum代替int常量"></a>7.用enum代替int常量</h2><h2 id="8-所有的入参和出参不要直接使用Map"><a href="#8-所有的入参和出参不要直接使用Map" class="headerlink" title="8.所有的入参和出参不要直接使用Map"></a>8.所有的入参和出参不要直接使用Map</h2><blockquote><p>失去了严谨的代码规范，日后出现bug的时候特别的难找</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//当有bug产生时，无法快速确定错误代码位置，时间长了可能都不知道这个方法做了什么，必须一步步调试才能知道最终这个返回的参数到底是什么东西</span><br><span class="line">public JSONObject methodA(params...) &#123;</span><br><span class="line">    ...</span><br><span class="line">    return methodB(params...);</span><br><span class="line">&#125;</span><br><span class="line">public JSONObject methodB(params...) &#123;</span><br><span class="line">    ...</span><br><span class="line">    JSONObject result = new JSONObject();</span><br><span class="line">    result.put(&quot;paramA&quot;, 1);</span><br><span class="line">    result.put(&quot;paramB&quot;, 2);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-要对每个实体类（包括成员属性）写上注释"><a href="#9-要对每个实体类（包括成员属性）写上注释" class="headerlink" title="9.要对每个实体类（包括成员属性）写上注释"></a>9.要对每个实体类（包括成员属性）写上注释</h2><blockquote><p>提高代码可读性，方便后期代码维护</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 代码规范和重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范和重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Alibaba 开源的 Java 诊断工具 Arthas</title>
      <link href="/blog/2022/10/16/JVM/Arthas/"/>
      <url>/blog/2022/10/16/JVM/Arthas/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Arthas 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。</p></blockquote><h1 id="官网地址"><a href="#官网地址" class="headerlink" title="官网地址"></a>官网地址</h1><blockquote><p><a href="https://arthas.aliyun.com/">https://arthas.aliyun.com</a></p></blockquote><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><blockquote><p>curl -O <a href="https://arthas.aliyun.com/arthas-boot.jar">https://arthas.aliyun.com/arthas-boot.jar</a><br>windows下载 <a href="https://github.com/alibaba/arthas/releases">https://github.com/alibaba/arthas/releases</a></p></blockquote><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><blockquote><p>java -jar arthas-boot.jar</p></blockquote><h1 id="Arthas-Tunnel（远程连接使用）"><a href="#Arthas-Tunnel（远程连接使用）" class="headerlink" title="Arthas Tunnel（远程连接使用）"></a>Arthas Tunnel（远程连接使用）</h1><blockquote><p>通过 Arthas Tunnel Server/Client 来远程管理/连接多个 Agent<br>统一授权登录服务器，对服务器可以通过agentId直接使用arthas诊断</p></blockquote><h2 id="统一的服务端"><a href="#统一的服务端" class="headerlink" title="统一的服务端"></a>统一的服务端</h2><ol><li>下载tunnel server<blockquote><p><a href="https://github.com/alibaba/arthas/releases">https://github.com/alibaba/arthas/releases</a></p></blockquote></li><li>启动服务<blockquote><p>java -jar  arthas-tunnel-server.jar</p></blockquote></li></ol><p>默认情况下，arthas tunnel server 的 web 端口是8080，arthas agent 连接的端口是7777。</p><p>启动之后，可以访问 <a href="http://127.0.0.1:8080/">http://127.0.0.1:8080/</a> ，再通过agentId连接到已注册的 arthas agent 上。</p><p>通过 Spring Boot 的 Endpoint，可以查看到具体的连接信息： <a href="http://127.0.0.1:8080/actuator/arthas">http://127.0.0.1:8080/actuator/arthas</a> ，登陆用户名是arthas，密码在 arthas tunnel server 的日志里可以找到，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">32851 [main] INFO  o.s.b.a.s.s.UserDetailsServiceAutoConfiguration</span><br><span class="line"></span><br><span class="line">Using generated security password: f1dca050-3777-48f4-a577-6367e55a78a2</span><br></pre></td></tr></table></figure><h2 id="目标机器"><a href="#目标机器" class="headerlink" title="目标机器"></a>目标机器</h2><blockquote><p>如果要用server去连接目标IP使用arthas的话,服务端必须启动的,否则这个AgentId是出不来的,因为要注册成功后才会出现这个ID</p></blockquote><ol><li>启动arthas<blockquote><p>java -jar arthas-boot.jar –tunnel-server ‘ws://192.168.117.128:7777/ws’ –target-ip 192.168.117.130</p></blockquote></li></ol><p>如果连接成功会在日志中输出id，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wiki       https://arthas.aliyun.com/doc                                        </span><br><span class="line">tutorials  https://arthas.aliyun.com/doc/arthas-tutorials.html                  </span><br><span class="line">version    3.6.6                                                                </span><br><span class="line">main_class                                                                      </span><br><span class="line">pid        2020                                                                 </span><br><span class="line">time       2022-10-16 08:55:37                                                  </span><br><span class="line">id         BZNJK8O6YFVX3VTOEJBL</span><br></pre></td></tr></table></figure><p>还可以用session命令来显示AgentId，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Name              Value                                                                                                                                                                                                                                                   </span><br><span class="line">--------------------------------------------------------                                                                                                                                                                                                                   </span><br><span class="line"> JAVA_PID          2020                                                                                                                                                                                                                                                    </span><br><span class="line"> SESSION_ID        4778665c-a079-429a-9b5b-7e8c6c274adf                                                                                                                                                                                                                    </span><br><span class="line"> AGENT_ID          BZNJK8O6YFVX3VTOEJBL                                                                                                                                                                                                                                    </span><br><span class="line"> TUNNEL_SERVER     ws://192.168.117.128:7777/ws                                                                                                                                                                                                                            </span><br><span class="line"> TUNNEL_CONNECTED  true</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><p>查看当前进程的信息</p><blockquote><p>dashboard</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ID      NAME                                            GROUP                   PRIORITY        STATE           %CPU            DELTA_TIME      TIME            INTERRUPTED     DAEMON</span><br><span class="line">-1      VM Periodic Task Thread                         -                       -1              -               0.09            0.004           0:2.135         false           true</span><br><span class="line">88      Timer-for-arthas-dashboard-2140f455-7b16-4372-9 system                  5               RUNNABLE        0.03            0.001           0:0.783         false           true</span><br><span class="line"></span><br><span class="line">Memory                                   used          total         max          usage         GC</span><br><span class="line">heap                                     73M           115M          866M         8.51%         gc.ps_scavenge.count                            12</span><br><span class="line">ps_eden_space                            42M           51M           304M         13.91%        gc.ps_scavenge.time(ms)                         203</span><br><span class="line">ps_survivor_space                        192K          512K          512K         37.50%        gc.ps_marksweep.count                           2</span><br><span class="line">ps_old_gen                               31M           63M           649M         4.80%         gc.ps_marksweep.time(ms)                        61</span><br><span class="line">nonheap                                  38M           46M           -1           83.48%</span><br><span class="line">code_cache                               9M            10M           240M         4.13%</span><br><span class="line">metaspace                                25M           32M           -1           80.01%</span><br><span class="line">compressed_class_space                   3M            4M            1024M        0.30%</span><br><span class="line">direct                                   8K            8K            -            100.01%</span><br><span class="line">mapped                                   0K            0K            -            0.00%</span><br><span class="line"></span><br><span class="line">Runtime</span><br><span class="line">os.name                                                                                         Linux</span><br><span class="line">os.version                                                                                      5.15.0-48-generic</span><br><span class="line">java.version                                                                                    1.8.0_342</span><br><span class="line">java.home                                                                                       /usr/lib/jvm/java-8-openjdk-amd64/jre</span><br><span class="line">systemload.average                                                                              0.00</span><br><span class="line">processors                                                                                      8</span><br><span class="line">timestamp/uptime                                                                                Sun Oct 16 09:31:20 UTC 2022/2211s</span><br></pre></td></tr></table></figure><blockquote><p>参数说明</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">线程区域</span><br><span class="line">ID： Java级别的县城ID，这个ID不能跟jstack中的nativeID一一对应</span><br><span class="line">NAME: 线程名</span><br><span class="line">GROUP: 线程组名</span><br><span class="line">PRIORITY: 线程优先级，只是JAVA给操作系统建议的一种优先级</span><br><span class="line">STATE:线程的状态</span><br><span class="line">CPU%:线程CPU的使用率。比如采样间隔为1000ms，某个线程的增量cpu时间为100ms，则CPU的使用率=100/1000 = 10%</span><br><span class="line">DELTA_TIME:上次采样之后线程运行增量CPU的时间，单位为秒</span><br><span class="line">TIME:线程运行总CPU时间，数据格式为分:秒</span><br><span class="line">INTERRUPTED:线程当前是否出去中断的状态</span><br><span class="line">DAEMON:是否为守护线程</span><br><span class="line">内存区域</span><br><span class="line">heap：堆内存信息</span><br><span class="line">eden_space：新生代中的eden区占用内存信息</span><br><span class="line">survivor_space：新生代中survivor区占用内存信息</span><br><span class="line">tenured_gen：老年代的内存占用信息</span><br><span class="line">nonheap：非堆的内存占用信息（非堆就是JVM留给自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法的代码都在非堆内存中）</span><br><span class="line">code_cache：JIT缓存区域占用内存信息</span><br><span class="line">metaspace：元数据区占用内存信息（受操作系统内存大小的限制）</span><br><span class="line">compressed_class_space：指针压缩 用32位的offset代表64位的classpointer</span><br><span class="line">direct：直接内存</span><br><span class="line">mapped：内存映射缓冲区（一般来说频繁读写文件可能导致此区域偏高）</span><br><span class="line">系统信息区域</span><br><span class="line">os.name：操作系统名称</span><br><span class="line">os.version：操作系统版本</span><br><span class="line">java.version：JAVA版本</span><br><span class="line">java.home：JDK路径</span><br><span class="line">systemload.average：平均负载（这个参数的意义暂时未知）</span><br><span class="line">processors：处理器个数</span><br><span class="line">timestamp/uptime：当前时间戳/当前系统启动时间-现在</span><br></pre></td></tr></table></figure></li><li><p>通过 thread 命令来获取到进程的 Main Class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread 1 | grep &#x27;main(&#x27;</span><br></pre></td></tr></table></figure></li><li><p>通过 jad 来反编译 Main Class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad arthasTest.MathGame</span><br></pre></td></tr></table></figure></li><li><p>通过watch命令来查看函数的返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch arthasTest.MathGame primeFactors returnObj</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式7大原则</title>
      <link href="/blog/2022/04/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F7%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>/blog/2022/04/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F7%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式的目的"><a href="#设计模式的目的" class="headerlink" title="设计模式的目的"></a>设计模式的目的</h1><ol><li>代码重用性（即：相同的代码，不用多次编写）</li><li>可读性（即：编程规范性，便于其他程序员的阅读和理解）</li><li>可扩展性（即：当需要增加新的功能时，非常的方便，称为可维护）</li><li>可靠性（即：当我们增加新的功能后，对原来的功能没有影响）</li><li>使程序呈现高内聚，低耦合的特性</li></ol><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><ul><li>定义：不要存在多于一个导致类变更的原因</li><li>一个类/接口/方法只负责一项职责或职能<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3></li><li>降低类的复杂度；</li><li>提高类的可读性，因为类的职能单一，看起来比较有目的性，显得简单；</li><li>提高系统的可维护性，降低变更程序引起的风险。<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3>如果一味追求这个单一职责，有时也会造成类的大爆炸。。。。。。。不过接口和方法应该遵循这个原则。</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>对类来说，一个类只负责一项职责。</p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</p><h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>依赖倒转原则是指：</p><ol><li>高层模块不应该依赖底层模块，二者都应该依赖其抽象</li><li>抽象不应该依赖细节，细节应该依赖抽象</li><li>依赖倒转的中心思想是面向接口编程</li><li>依赖倒转原则是基于这样的理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类</li><li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</li></ol><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>要针对接口编程，而不是针对实现编程。在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入</p><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><ol><li>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代还成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。</li><li>在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法</li><li>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题</li></ol><h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h3><p>尽量不要重写父类的方法</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><ol><li>一个软件实体如类，模块和函数应该对扩展开放（对提供方，比如增加类），对修改关闭（对使用方）。用抽象构建框架，用实体扩展细节。</li><li>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><ol><li>一个对象应该对其他对象保持最少的了解</li><li>类与类关系越密切，耦合度越大</li><li>迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好，也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部，对外除了提供public方法，不对外泄露任何信息</li><li>迪米特法则还有个更简单的定义：只与直接的朋友通信</li><li>直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部</li></ol><h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>原则是尽量使用合成/聚合的方式，而不是使用继承</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编译都通过不了</p><ol><li>类中用到了对方</li><li>如果是类的成员属性</li><li>如果是方法的返回类型</li><li>是方法接收的参数类型</li><li>方法中使用到<br><img src="/blog/img/md/%E9%9D%A2%E8%AF%95%E9%A2%98/04.png" alt="图1"></li></ol><h3 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h3><p>泛化关系实际上就是继承关系，他是继承关系的特例</p><ol><li>泛化关系实际上就是继承关系</li><li>如果A类继承了B类，我们就说A和B存在泛化关系<br><img src="/blog/img/md/%E9%9D%A2%E8%AF%95%E9%A2%98/05.png" alt="图1"></li></ol><h3 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h3><p>实现关系实际上就是A类实现B类，他是依赖关系的特例<br><img src="/blog/img/md/%E9%9D%A2%E8%AF%95%E9%A2%98/06.png" alt="图1"></p><h3 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h3><p>关联关系实际上就是类与类之间的联系，他是依赖关系的特例<br><img src="/blog/img/md/%E9%9D%A2%E8%AF%95%E9%A2%98/07.png" alt="图1"></p><h3 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h3><p>表示的是整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例，所以他具有关联的导航性与多重性<br><img src="/blog/img/md/%E9%9D%A2%E8%AF%95%E9%A2%98/08.png" alt="图1"></p><p>（用set方法注入）</p><h3 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h3><p>如果整体与部分无法分开，则升级为组合关系<br>如果在程序中Person实体中定义了对IDCard进行级联删除，即删除Person时连同IDCard一起删除，那么IDCard和Person就是组合了.</p><p><img src="/blog/img/md/%E9%9D%A2%E8%AF%95%E9%A2%98/09.png" alt="图1"></p><p>（直接new）</p><p><img src="/blog/img/md/%E9%9D%A2%E8%AF%95%E9%A2%98/10.png" alt="图1"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式（一）单例模式</title>
      <link href="/blog/2022/04/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2022/04/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="一、单例模式"><a href="#一、单例模式" class="headerlink" title="一、单例模式"></a>一、单例模式</h1><h2 id="一、饿汉式（静态常量）-可用"><a href="#一、饿汉式（静态常量）-可用" class="headerlink" title="一、饿汉式（静态常量）[可用]"></a>一、饿汉式（静态常量）[可用]</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private final static Singleton INSTANCE = new Singleton();</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、饿汉式（静态代码块）-可用"><a href="#二、饿汉式（静态代码块）-可用" class="headerlink" title="二、饿汉式（静态代码块）[可用]"></a>二、饿汉式（静态代码块）[可用]</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton instance;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        instance = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public Singleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、懒汉式-线程不安全-不可用"><a href="#三、懒汉式-线程不安全-不可用" class="headerlink" title="三、懒汉式(线程不安全)[不可用]"></a>三、懒汉式(线程不安全)[不可用]</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton singleton;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (singleton == null) &#123;</span><br><span class="line">            singleton = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、懒汉式-线程安全，同步方法-不推荐用"><a href="#四、懒汉式-线程安全，同步方法-不推荐用" class="headerlink" title="四、懒汉式(线程安全，同步方法)[不推荐用]"></a>四、懒汉式(线程安全，同步方法)[不推荐用]</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton singleton;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized Singleton getInstance() &#123;</span><br><span class="line">        if (singleton == null) &#123;</span><br><span class="line">            singleton = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：效率太低了，每个线程在想获得类的实例时候，执行 getInstance() 方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。方法进行同步效率太低要改进。</p><h2 id="五、懒汉式-线程安全，同步代码块-不可用"><a href="#五、懒汉式-线程安全，同步代码块-不可用" class="headerlink" title="五、懒汉式(线程安全，同步代码块)[不可用]"></a>五、懒汉式(线程安全，同步代码块)[不可用]</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton singleton;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (singleton == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                singleton = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于第四种实现方式同步效率太低，所以摒弃同步方法，改为同步产生实例化的的代码块。但是这种同步并不能起到线程同步的作用。跟第 3 种实现方式遇到的情形一致，假如一个线程进入了 if (singleton == null) 判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。</p><h2 id="六、双重检查-推荐用"><a href="#六、双重检查-推荐用" class="headerlink" title="六、双重检查[推荐用]"></a>六、双重检查[推荐用]</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static volatile Singleton singleton;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (singleton == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (singleton == null) &#123;</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Double-Check 概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次 if (singleton == null) 检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断 if (singleton == null)，直接 return 实例化对象。</p><p>volatile关键字为了防止编译器指令重排</p><p>优点：线程安全；延迟加载；效率较高</p><h2 id="七、静态内部类-推荐用"><a href="#七、静态内部类-推荐用" class="headerlink" title="七、静态内部类[推荐用]"></a>七、静态内部类[推荐用]</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static class SingletonInstance &#123;</span><br><span class="line">        private static final Singleton INSTANCE = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要 Singleton 类被装载就会实例化，没有 Lazy-Loading 的作用，而静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。</p><p>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</p><p>优点：避免了线程不安全，延迟加载，效率高</p><h2 id="八、枚举-推荐用"><a href="#八、枚举-推荐用" class="headerlink" title="八、枚举[推荐用]"></a>八、枚举[推荐用]</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void whateverMethod() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。可能是因为枚举在 JDK1.5 中才添加，所以在实际项目开发中，很少见人这么写过</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单点故障与分布式锁</title>
      <link href="/blog/2022/04/28/Zookeeper/%E5%8D%95%E7%82%B9%E6%95%85%E9%9A%9C%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/blog/2022/04/28/Zookeeper/%E5%8D%95%E7%82%B9%E6%95%85%E9%9A%9C%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是zookeeper"><a href="#什么是zookeeper" class="headerlink" title="什么是zookeeper"></a>什么是zookeeper</h1><blockquote><p>服务注册与发现中心<br>解决了分布式锁的问题</p></blockquote><h2 id="单点故障"><a href="#单点故障" class="headerlink" title="单点故障"></a>单点故障</h2><p>有一个主服务器，两个从服务器，主服务器调用两个从服务器，主服务器挂了，两个从服务还可以调用服务，这就是单点故障<br>传统解决方案是：有一个备用节点，当主节点挂了，备用节点代替主节点，但之前的主节点可能只是因为网络问题，没有及时返回备用节点，所以备用节点误以为主节点挂了，就会出现双主问题，请求会重复，数据就会有问题。</p><h3 id="解决单点故障，分布式锁"><a href="#解决单点故障，分布式锁" class="headerlink" title="解决单点故障，分布式锁"></a>解决单点故障，分布式锁</h3><p>zookeeper：所有的服务器都向zookeeper注册，zookeeper维护了一个节点列表，zookeeper会进行选举，剩下的备用节点就会进入阻塞状态，当出现网络震荡的时候，主节点会从zookeeper列表中删除，删除后由备用节点继续选举。如果原来的主节点网络震荡后重新上线，它就会重新注册成另一个新的节点，成为备用节点。</p><h3 id="为什么需要分布式锁"><a href="#为什么需要分布式锁" class="headerlink" title="为什么需要分布式锁"></a>为什么需要分布式锁</h3><p>用户下订单 访问服务器，通过了nginx负载均衡，发放到3个订单服务器上，3个服务器同时下订单，会产生数据错误</p><h3 id="什么是zookeeper-1"><a href="#什么是zookeeper-1" class="headerlink" title="什么是zookeeper?"></a>什么是zookeeper?</h3><blockquote><p>zookeeper是一个为分布式应用提供一致性的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一的文件名</p></blockquote><h3 id="zookeeper实现分布式锁的步骤"><a href="#zookeeper实现分布式锁的步骤" class="headerlink" title="zookeeper实现分布式锁的步骤"></a>zookeeper实现分布式锁的步骤</h3><ol><li>创建一个目录MyZookeeper</li><li>线程A想获取锁就在MyZookeeper目录下创建临时顺序节点</li><li>获取MyZookeeper目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁</li><li>线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点</li><li>线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁</li></ol><p>线程 A</p><pre><code>拿到master-002节点，和其他节点比对，发现master-001节点比自己小,获取master-001节点</code></pre><p>线程 B</p><pre><code>master-002，发现线程A在用master-001，就监听master-001节点的状态</code></pre><p>MyZookeeper</p><pre><code>master-001master-002master-0033个主节点等着被调用</code></pre><p>就是3个服务等着被调用，并发线程A、B进来调用，A首先拿到了master-002，发现自己拿的有更小的master-001，就获取master-001，线程B进来获取了master-002，发现线程A在用master-001，就监听master-001节点的状态，线程A处理完后，释放了锁，删除了master-001节点，线程B监听到了master-001的变化，就再一判断自己是不是最小的节点，如果是就获得锁</p>]]></content>
      
      
      <categories>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态代理</title>
      <link href="/blog/2022/04/28/Java/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/blog/2022/04/28/Java/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>创建接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IPerson &#123;</span><br><span class="line">    public void sayHi();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的实现类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class PersonImpl implements IPerson &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHi() &#123;</span><br><span class="line">        System.out.println(666);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MainProxy implements IPerson &#123;</span><br><span class="line">    private IPerson target;</span><br><span class="line"></span><br><span class="line">    public IPerson getTarget() &#123;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MainProxy setTarget(IPerson target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sayHi() &#123;</span><br><span class="line">        if (target != null) &#123;</span><br><span class="line">            System.out.println(&quot;man say invoked at : &quot; + System.currentTimeMillis());</span><br><span class="line">            target.sayHi();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MainProxy proxy = new MainProxy();</span><br><span class="line">        proxy.setTarget(new PersonImpl()).sayHi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>每个代理类都要实现接口，难维护</p><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>创建接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IPerson &#123;</span><br><span class="line">    public void sayHi();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的实现类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class PersonImpl implements IPerson &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHi() &#123;</span><br><span class="line">        System.out.println(666);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    public MyInvocationHandler(Object target)&#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;方法执行前&quot;);</span><br><span class="line">        method.invoke(target,args);</span><br><span class="line">        System.out.println(&quot;方法执行后&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IPerson person = new PersonImpl();</span><br><span class="line">        MyInvocationHandler myInvocationHandler = new MyInvocationHandler(person);</span><br><span class="line">        IPerson proxyPerson = (IPerson)Proxy.newProxyInstance(person.getClass().getClassLoader(),</span><br><span class="line">                person.getClass().getInterfaces(), myInvocationHandler);</span><br><span class="line">        proxyPerson.sayHi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>代理的对象是Object类型，所以它是被多个接口代理复用的，解决静态代理类爆炸，维护困难的问题，但是被代理的类一定要实现接口</p><h1 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h1><p>可以代理没有接口的普通类</p><p>CGLIB原理：动态生成一个要代理类的子类，子类重写要代理的类的所有不是final的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。它比使用java反射的JDK动态代理要快。</p><p>CGLIB缺点：对于final方法，无法进行代理。</p><p>创建普通类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class PersonService &#123;</span><br><span class="line"></span><br><span class="line">    public PersonService()&#123;</span><br><span class="line">        System.out.println(&quot;PersonService的构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    final public String getPerson(String code)&#123;</span><br><span class="line">        System.out.println(&quot;PersonService:getPerson&gt;&gt;&quot;+code);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPerson() &#123;</span><br><span class="line">        System.out.println(&quot;PersonService:setPerson&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建代理类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class CglibProxyInterceptor implements MethodInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object sub, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;执行前...&quot;);</span><br><span class="line">        Object object = methodProxy.invokeSuper(sub, objects);</span><br><span class="line">        System.out.println(&quot;执行后...&quot;);</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        enhancer.setSuperclass(PersonService.class);</span><br><span class="line">        enhancer.setCallback(new CglibProxyInterceptor());</span><br><span class="line">        PersonService proxy= (PersonService)  enhancer.create();</span><br><span class="line">        proxy.setPerson();</span><br><span class="line">        proxy.getPerson(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql优化</title>
      <link href="/blog/2022/04/28/Mysql/mysql%E4%BC%98%E5%8C%96/"/>
      <url>/blog/2022/04/28/Mysql/mysql%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="为什么要优化"><a href="#为什么要优化" class="headerlink" title="为什么要优化"></a>为什么要优化</h2><ul><li>系统的吞吐量瓶颈往往出现在数据库的访问速度上</li><li>随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</li><li>数据是存放在磁盘上的，读写速度无法和内存相比</li></ul><h2 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h2><ul><li>设计数据库时：数据库表、字段的设计，存储引擎</li><li>利用好MySQL自身提供的功能，如索引等</li><li>横向扩展：MySQL集群、负载均衡、读写分离</li><li>SQL语句的优化（收效甚微）</li></ul><h1 id="字段设计"><a href="#字段设计" class="headerlink" title="字段设计"></a>字段设计</h1><blockquote><p>字段类型的选择，设计规范，范式，常见设计案例</p></blockquote><h2 id="原则：尽量使用整型表示字符串"><a href="#原则：尽量使用整型表示字符串" class="headerlink" title="原则：尽量使用整型表示字符串"></a>原则：尽量使用整型表示字符串</h2><h3 id="存储IP"><a href="#存储IP" class="headerlink" title="存储IP"></a>存储IP</h3><p>INET_ATON(str)，address to number<br>INET_NTOA(number)，number to address</p><h3 id="MySQL内部的枚举类型（单选）和集合（多选）类型"><a href="#MySQL内部的枚举类型（单选）和集合（多选）类型" class="headerlink" title="MySQL内部的枚举类型（单选）和集合（多选）类型"></a>MySQL内部的枚举类型（单选）和集合（多选）类型</h3><blockquote><p>decimal不会损失精度，存储空间会随数据的增大而增大。double占用固定空间，较大数的存储会损失精度。非定长的还有varchar、text</p></blockquote><h3 id="金额"><a href="#金额" class="headerlink" title="金额"></a>金额</h3><blockquote><p>对数据的精度要求较高，小数的运算和存储存在精度问题（不能将所有小数转换成二进制）</p></blockquote><h3 id="定点数decimal"><a href="#定点数decimal" class="headerlink" title="定点数decimal"></a>定点数decimal</h3><p>price decimal(8,2)有2位小数的定点数，定点数支持很大的数（甚至是超过int,bigint存储范围的数）</p><h3 id="小单位大数额避免出现小数"><a href="#小单位大数额避免出现小数" class="headerlink" title="小单位大数额避免出现小数"></a>小单位大数额避免出现小数</h3><p>元-&gt;分</p><h3 id="字符串存储"><a href="#字符串存储" class="headerlink" title="字符串存储"></a>字符串存储</h3><p>定长char，非定长varchar、text（上限65535，其中varchar还会消耗1-3字节记录长度，而text使用额外空间记录长度）</p><h2 id="原则：尽可能选择小的数据类型和指定短的长度"><a href="#原则：尽可能选择小的数据类型和指定短的长度" class="headerlink" title="原则：尽可能选择小的数据类型和指定短的长度"></a>原则：尽可能选择小的数据类型和指定短的长度</h2><h2 id="原则：尽可能使用-not-null"><a href="#原则：尽可能使用-not-null" class="headerlink" title="原则：尽可能使用 not null"></a>原则：尽可能使用 not null</h2><p>非null字段的处理要比null字段的处理高效些！且不需要判断是否为null。</p><p>null在MySQL中，不好处理，存储需要额外空间，运算也需要特殊的运算符。如select null = null和select null &lt;&gt; null（&lt;&gt;为不等号）有着同样的结果，只能通过is null和is not null来判断字段是否为null。</p><p>如何存储？MySQL中每条记录都需要额外的存储空间，表示每个字段是否为null。因此通常使用特殊的数据进行占位，比如int not null default 0、string not null default ‘’</p><h2 id="原则：字段注释要完整，见名知意"><a href="#原则：字段注释要完整，见名知意" class="headerlink" title="原则：字段注释要完整，见名知意"></a>原则：字段注释要完整，见名知意</h2><h2 id="原则：单表字段不宜过多"><a href="#原则：单表字段不宜过多" class="headerlink" title="原则：单表字段不宜过多"></a>原则：单表字段不宜过多</h2><p>二三十个就极限了</p><h2 id="原则：可以预留字段"><a href="#原则：可以预留字段" class="headerlink" title="原则：可以预留字段"></a>原则：可以预留字段</h2><blockquote><p>在使用以上原则之前首先要满足业务需求</p></blockquote><h2 id="执行计划explain"><a href="#执行计划explain" class="headerlink" title="执行计划explain"></a>执行计划explain</h2>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList</title>
      <link href="/blog/2022/04/28/Java/LinkedList/"/>
      <url>/blog/2022/04/28/Java/LinkedList/</url>
      
        <content type="html"><![CDATA[<p>LinkedList 是一个继承于AbstractSequentialList的双向循环链表。它也可以被当作堆栈、队列或双端队列进行操作。 LinkedList 实现 List 接口，能对它进行队列操作。 LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。 LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。 LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。 LinkedList 是非同步的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务</title>
      <link href="/blog/2022/04/28/Spring/Spring%E4%BA%8B%E5%8A%A1/"/>
      <url>/blog/2022/04/28/Spring/Spring%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>事务是一个不可分割的单位，要么都发生，要么都不发生。</p><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>事务执行前后数据的完整性必须保持一致。</p><h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务干扰。多个并发事务的数据相互隔离。</p><h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>事务一旦被提交后，数据就会被持久化到数据库中。</p><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><blockquote><p>事务隔离级别的设置是为了解决脏读，不可重复读，幻读等问题的。<br>下面来看下这几个问题的描述。</p></blockquote><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p>一个事务a读取了另一个事务b改写还未提交的数据，如果另一个事务b回滚，事务a读取到的数据是无效的。</p><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>在同一个事务中，多次读取同一数据读取到的结果不同。比如事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</p><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>一个事务读取了几行数据后，另一个事务插入了新的数据后，幻读就发生了。再后来的查询中，第一个事务就会发现一些原来没有的数据。比如系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p><blockquote><p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。<br>为解决上面几个问题，引入事务隔离级别的概念。</p></blockquote><h1 id="事务隔离级别-1"><a href="#事务隔离级别-1" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p><img src="/blog/img/md/%E9%9D%A2%E8%AF%95%E9%A2%98/02.png" alt="图1"></p><blockquote><p>其中Spring中默认设置的default隔离级别的值就是数据库的默认隔离级别，比如mysql的默认隔离级别就是repeatable_read级别。</p></blockquote><h1 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h1><blockquote><p>应用架构通常分为web层，service层和持久化层。一般事务机制添加在service层上，service层中的多个方法之间的调用就涉及到事务传播机制，当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。<br>事务传播行为有下面几种：</p></blockquote><p><img src="/blog/img/md/%E9%9D%A2%E8%AF%95%E9%A2%98/03.png" alt="图1"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK1.8 HashMap</title>
      <link href="/blog/2022/04/28/Java/JDK1.8%20HashMap/"/>
      <url>/blog/2022/04/28/Java/JDK1.8%20HashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK1-8-HashMap"><a href="#JDK1-8-HashMap" class="headerlink" title="JDK1.8 HashMap"></a>JDK1.8 HashMap</h1><h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; //默认容量16</span><br><span class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //最大容量</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f; //默认负载因子</span><br><span class="line">static final int TREEIFY_THRESHOLD = 8; //链表节点转红黑树节点的阙值</span><br><span class="line">static final int UNTREEIFY_THRESHOLD = 6; //红黑树节点转链表节点的阙值，6个节点转</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY = 64; //转红黑树时，table的最小长度</span><br></pre></td></tr></table></figure><h2 id="定位哈希桶数组索引位置"><a href="#定位哈希桶数组索引位置" class="headerlink" title="定位哈希桶数组索引位置"></a>定位哈希桶数组索引位置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//代码1</span><br><span class="line">static final int hash(Object key) &#123; //计算key的hash值</span><br><span class="line">    int h;</span><br><span class="line">    //先拿到key的hashCode值;2.将hashCode的高16参与运算（异或运算）</span><br><span class="line">    //异或运算：1^1=0 0^1=1 0^0=0 相同为0 不同为1</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line">//代码2</span><br><span class="line">int n = tab.length;</span><br><span class="line">// 将（tab.length - 1）与hash值进行&amp;运算</span><br><span class="line">int index = (n -1) &amp; hash;</span><br></pre></td></tr></table></figure><p>整个过程本质上就是三步：</p><ol><li>拿到key的hashCode值</li><li>将hashCode的高位参与运算，重新计算hash值</li><li>将计算出来的hash值与(table.length - 1)进行&amp;运算</li></ol><p>下图是一个简单的例子，table长度为16：<br><img src="https://note.youdao.com/yws/public/resource/5d0022e3a085d56a95c3c3120ca07735/xmlnote/9FCF54B605B04111A28F540CC44BB437/2359"></p><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    //table 是否为空或者length等于，如果是则调用resize方法进行初始化</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    //通过hash值计算索引位置，如果table该索引位置的节点为空则新增一个</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)  //将索引的头结点赋值给p</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;  //table该索引位置不为空</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        if (p.hash == hash &amp;&amp; // 判断p节点的hash值和key值跟传入的hash值和key值是否相等</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;  // 如果相等，则p节点即为要查找的目标节点，赋值给e</span><br><span class="line">        //判断p节点是否为TreeNode，如果是则调用红黑树的putTreeVal方法查找目标节点</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123; // 到这代表p节点为普通链表节点</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123; //遍历链表，binCount用于统计节点数</span><br><span class="line">                if ((e = p.next) == null) &#123; //p.next为空代表不存在目标节点则新增一个节点插入链表尾部</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    //计算节点数是否超过8个，减一是因为循环从p节点的下一个节点开始的</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash); // 如果超过8个，调用treeifyBin将该链表转换为红黑树</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break; //e节点的hash值和key值与传入的相等，则e即为目标节点，跳出循环</span><br><span class="line">                p = e; // 将p指向下一个节点</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // e不为空则代表根据传入的hash值和key值查找到了节点，将该节点的value覆盖，返回原来的值</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e); //用于LinkedHashMap</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount; //modCount用于记录HashMap的修改次数</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="treeifyBin-将该链表转换为红黑树"><a href="#treeifyBin-将该链表转换为红黑树" class="headerlink" title="treeifyBin 将该链表转换为红黑树"></a>treeifyBin 将该链表转换为红黑树</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">    int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    // table为空或者table的数组长度小于64，进行扩容</span><br><span class="line">    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    //根据hash值计算索引值，遍历该索引位置的链表</span><br><span class="line">    else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">        do &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); //链表节点转红黑树节点</span><br><span class="line">            if (tl == null) //tl为空代表第一次循环</span><br><span class="line">                hd = p; //头结点</span><br><span class="line">            else &#123;</span><br><span class="line">                p.prev = tl; //当前节点的prev属性设为上一个节点</span><br><span class="line">                tl.next = p; //上一个节点的next属性设置为当前节点</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p; //tl赋值为p，在下一次循环中作为上一个节点</span><br><span class="line">        &#125; while ((e = e.next) != null); //e指向下一个节点</span><br><span class="line">        // 将table该索引位置赋值为新转的TreeNode的头节点</span><br><span class="line">        if ((tab[index] = hd) != null)</span><br><span class="line">            hd.treeify(tab); //以头节点为根节点，构建红黑树</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="replacementTreeNode方法解析"><a href="#replacementTreeNode方法解析" class="headerlink" title="replacementTreeNode方法解析"></a>replacementTreeNode方法解析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 该方法只是调用了TreeNode类的构造方法，依据当前节点信息构造一个树节点对象</span><br><span class="line">TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 首先该类是HashMap类的一个静态内部类</span><br><span class="line"> * 包内可见、不可被继承</span><br><span class="line"> * 该类继承了LinkedHashMap.Entry，而LinkedHashMap.Entry继承了HashMap.Node</span><br><span class="line"> * PS：要知道LinkedHashMap是HashMap的子类，然而目前的状况是HashMap作为父类，他的一个静态内部类（TreeNode）居然继承了子类LinkedHashMap的一个静态内部类</span><br><span class="line"> *（LinkedHashMap.Entry），这个设计不太理解。</span><br><span class="line"> * 红黑树是一个二叉树，父节点、左节点、右节点、红黑标识都是二叉树中的元素</span><br><span class="line"> */</span><br><span class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  // red-black tree links</span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</span><br><span class="line">    boolean red;</span><br><span class="line">    TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, val, next); // 此处调用 LinkedHashMap.Entry的构造方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来再看下LinkedHashMap.Entry类的定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 首先该类是LinkedHashMap的一个静态内部类</span><br><span class="line"> * 包内可见、又因为没有final修饰符（所以HashMap中的TreeNode类才能继承到他）</span><br><span class="line"> * 该类除了增加了before、after两个实例变量之外，没有任何的行为扩展，也就是说他的所有行为都继承自HashMap.Node</span><br><span class="line"> * 该类也只有一个构造方法，且该构造方法就是通过调用HashMap.Node的构造方法构造一个HashMap.Node对象</span><br><span class="line"> * PS：看到这里就更加不理解为何HashMap.TreeNode不直接继承HashMap.Node，而要绕个弯来继承LinkedHashMap.Entry，难道是为了使用before、after？可貌似也没有使用到。</span><br><span class="line"> */</span><br><span class="line">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="treeify-构建红黑树"><a href="#treeify-构建红黑树" class="headerlink" title="treeify 构建红黑树"></a>treeify 构建红黑树</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">final void treeify(Node&lt;K,V&gt;[] tab) &#123; //构建红黑树</span><br><span class="line">    TreeNode&lt;K,V&gt; root = null;</span><br><span class="line">    for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) &#123; //this即为调用此方法的TreeNode</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next; //next赋值为x的下一个节点</span><br><span class="line">        x.left = x.right = null; //将x的左右节点设置为空</span><br><span class="line">        if (root == null) &#123; //如果还没有根节点，则将x设置为根节点</span><br><span class="line">            x.parent = null; //根节点没有父节点</span><br><span class="line">            x.red = false; //根节点必须为黑色</span><br><span class="line">            root = x; //将x设置为根节点</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            K k = x.key;        // k赋值为x的key</span><br><span class="line">            int h = x.hash;     // h赋值为x的hash值</span><br><span class="line">            Class&lt;?&gt; kc = null;</span><br><span class="line">            //如果当前节点x不是根节点，则从根节点开始查找属于该节点的位置</span><br><span class="line">            for (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                int dir, ph;</span><br><span class="line">                K pk = p.key;</span><br><span class="line">                if ((ph = p.hash) &gt; h) //如果x节点的hash值小于p节点的hash值</span><br><span class="line">                    dir = -1; //则将dir赋值为-1，代表x节点的hash值小于p节点的hash值</span><br><span class="line">                else if (ph &lt; h) //与上面相反，如果x节点的hash值大于p节点的hash值</span><br><span class="line">                    dir = 1;    //则将dir赋值为1，代表向p的右边查找</span><br><span class="line">                </span><br><span class="line">                //走到这代表x的hash值和p的hash值相等，则比较key值</span><br><span class="line">                else if ((kc == null &amp;&amp; //如果k没有实现Comparable接口 或者 x节点key和p节点key相等</span><br><span class="line">                          (kc = comparableClassFor(k)) == null) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == 0)</span><br><span class="line">                         //使用定义的一套规则来比较x节点和p节点的大小，用来决定向左还是向右查找</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p; //xp赋值为x的父节点，中间变量，用于下面给x的父节点赋值</span><br><span class="line">                //dir&lt;=0则向p左边查找，否则向p右边查找，如果为null，则代表该位置即为x的目标位置</span><br><span class="line">                if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123;</span><br><span class="line">                    x.parent = xp; //x的父节点即为最后一次遍历的p节点</span><br><span class="line">                    if (dir &lt;= 0) //如果dir&lt;=0，则代表x节点为父节点的左节点</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    else    //如果dir&gt;0，则代表x节点为父节点右节点</span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    // 进行红黑树的插入平衡（通过左旋、右旋和改变节点颜色来保证当前树符合红黑树的要求）</span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    moveRootToFront(tab, root); //如果root节点不在table索引位置的头结点，则将root节点调整到索引位置的头结点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="moveRootToFront-将root节点调整到索引位置的头结点"><a href="#moveRootToFront-将root节点调整到索引位置的头结点" class="headerlink" title="moveRootToFront //将root节点调整到索引位置的头结点"></a>moveRootToFront //将root节点调整到索引位置的头结点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//如果当前索引位置的头结点不是root节点，则将root的上一个节点和下一个节点进行关联</span><br><span class="line">//（转成红黑树后，链式结构还是存在的）将root放到头节点的位置，原头节点放在root的next节点上</span><br><span class="line">static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) &#123;</span><br><span class="line">    int n;</span><br><span class="line">    if (root != null &amp;&amp; tab != null &amp;&amp; (n = tab.length) &gt; 0) &#123;</span><br><span class="line">        int index = (n - 1) &amp; root.hash;</span><br><span class="line">        TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">        if (root != first) &#123; //如果root节点不是该索引位置的头节点</span><br><span class="line">            Node&lt;K,V&gt; rn;</span><br><span class="line">            tab[index] = root; //将该索引位置的头节点赋值为root节点</span><br><span class="line">            TreeNode&lt;K,V&gt; rp = root.prev; //root节点的上一个节点</span><br><span class="line">            // 如果root节点的下一个节点不为空，</span><br><span class="line">            // 则将root节点的下一个节点prev属性设置为root节点的上一个节点</span><br><span class="line">            if ((rn = root.next) != null)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">            if (rp != null)</span><br><span class="line">                rp.next = rn;</span><br><span class="line">            if (first != null) //如果原头节点不为空，则将原头节点的prev属性设置为root节点</span><br><span class="line">                first.prev = root;</span><br><span class="line">            root.next = first; //将root节点的next属性设置为原头节点</span><br><span class="line">            root.prev = null;</span><br><span class="line">        &#125;</span><br><span class="line">        assert checkInvariants(root); //检查树是否正常</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="resize-扩容或初始化"><a href="#resize-扩容或初始化" class="headerlink" title="resize 扩容或初始化"></a>resize 扩容或初始化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123; //老table不为空</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; //老table的容量超过最大容量值</span><br><span class="line">            threshold = Integer.MAX_VALUE; //设置阙值为Integer.MAX_VALUE</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果容量*2&lt;最大容量并且&gt;=16，则将阙值设置为原来的两倍</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) // 老表的容量为0，老表的阙值大于0，是因为初始容量被放入阙值</span><br><span class="line">        newCap = oldThr; //则将新表的容量设置为老表的阙值</span><br><span class="line">    else &#123;               // 老表的容量为0，老表的阙值为0，则为空表，设置默认容量和阙值</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    if (newThr == 0) &#123; //如果新表的阙值为空，则通过新的容量*负载因子获得阙值</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; //将当前阙赋值为刚计算出来的新的阙值</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">    </span><br><span class="line">    //定义新表，容量为刚计算出来的新容量</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab; //将当前的表赋值为新定义的表</span><br><span class="line">    if (oldTab != null) &#123; //如果老表不为空，则需遍历将节点赋值给新表</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123; //将索引值为j的老表头结点赋值给e</span><br><span class="line">                oldTab[j] = null; //将老表的节点设置为空，以便垃圾收集器回收空间</span><br><span class="line">                //如果e.next为空，则代表老表的该位置只有一个节点</span><br><span class="line">                //通过hash值计算新表的索引位置，直接将该节点放在该位置</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    //调用treeNode的hash分布（跟下面最后一个else的内容几乎相同）</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; // preserve order</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList</title>
      <link href="/blog/2022/04/28/Java/ArrayList/"/>
      <url>/blog/2022/04/28/Java/ArrayList/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList的主要成员变量"><a href="#ArrayList的主要成员变量" class="headerlink" title="ArrayList的主要成员变量"></a>ArrayList的主要成员变量</h1><p>private static final int DEFAULT_CAPACITY = 10；</p><blockquote><p>当ArrayList的构造方法中没有显示指出ArrayList的数组长度时，类内部使用默认缺省时对象数组的容量大小，为10。</p></blockquote><p>private static final Object[] EMPTY_ELEMENTDATA = {};</p><blockquote><p>当ArrayList的构造方法中显示指出ArrayList的数组长度为0时，类内部将EMPTY_ELEMENTDATA 这个空对象数组赋给elemetData数组。</p></blockquote><p>private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};</p><blockquote><p>当ArrayList的构造方法中没有显示指出ArrayList的数组长度时，类内部使用默认缺省时对象数组为DEFAULTCAPACITY_EMPTY_ELEMENTDATA。</p></blockquote><p>transient Object[] elemetData;</p><blockquote><p>ArrayList的底层数据结构，只是一个对象数组，用于存放实际元素，并且被标记为transient，也就意味着在序列化的时候此字段是不会被序列化的。</p></blockquote><p>private int size;</p><blockquote><p>实际ArrayList中存放的元素的个数，默认时为0个元素。</p></blockquote><p>private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE – 8;</p><blockquote><p>ArrayList中的对象数组的最大数组容量为Integer.MAX_VALUE – 8。</p></blockquote><h1 id="ArrayList的构造方法"><a href="#ArrayList的构造方法" class="headerlink" title="ArrayList的构造方法"></a>ArrayList的构造方法</h1><p>无参构造方法<br>对于无参构造方法，将成员变量elementData的值设为DEFAULTCAPACITY_EMPTY_ELEMENTDATA。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList() &#123; </span><br><span class="line">        // 无参构造函数，设置元素数组为空 </span><br><span class="line">        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>int类型参数构造方法<br>参数为希望的ArrayList的数组的长度，initialCapacity。首先要判断参数initialCapacity与0的大小关系：</p><p>如果initialCapacity大于0，则创建一个大小为initialCapacity的对象数组赋给elementData。</p><p>如果initialCapacity等于0，则将EMPTY_ELEMENTDATA赋给elementData。</p><p>如果initialCapacity小于0，抛出异常（非法的容量）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity &gt; 0) &#123; // 初始容量大于0</span><br><span class="line">        this.elementData = new Object[initialCapacity]; // 初始化元素数组</span><br><span class="line">    &#125; else if (initialCapacity == 0) &#123; // 初始容量为0</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA; // 为空对象数组</span><br><span class="line">    &#125; else &#123; // 初始容量小于0，抛出异常</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Collection&lt;? extends E&gt;类型构造方法<br>第一步，将参数中的集合转化为数组赋给elementData；</p><p>第二步，参数集合是否是空。通过比较size与第一步中的数组长度的大小。</p><p>第三步，如果参数集合为空，则设置元素数组为空，即将EMPTY_ELEMENTDATA赋给elementData；</p><p>第四步，如果参数集合不为空，接下来判断是否成功将参数集合转化为Object类型的数组，如果转化成Object类型的数组成功，则将数组进行复制，转化为Object类型的数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(Collection&lt;? extends E&gt; c) &#123; // 集合参数构造函数</span><br><span class="line">    elementData = c.toArray(); // 转化为数组</span><br><span class="line">    if ((size = elementData.length) != 0) &#123; // 参数为非空集合</span><br><span class="line">        if (elementData.getClass() != Object[].class) // 是否成功转化为Object类型数组</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class); // 不为Object数组的话就进行复制</span><br><span class="line">    &#125; else &#123; // 集合大小为空，则设置元素数组为空</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ArrayList的add-方法"><a href="#ArrayList的add-方法" class="headerlink" title="ArrayList的add()方法"></a>ArrayList的add()方法</h1><p>在add()方法中主要完成了三件事：首先确保能够将希望添加到集合中的元素能够添加到集合中，即确保ArrayList的容量（判断是否需要扩容）；然后将元素添加到elementData数组的指定位置；最后将集合中实际的元素个数加1。</p><p>public boolean add(E e) { // 添加元素<br>    ensureCapacityInternal(size + 1);  // 判断是否需要扩容<br>    elementData[size++] = e;//添加元素<br>    return true;<br>}</p><h1 id="ensureCapacityInternal"><a href="#ensureCapacityInternal" class="headerlink" title="ensureCapacityInternal"></a>ensureCapacityInternal</h1><blockquote><p>确定集合为了确保添加元素成功是否需要对现有的元素数组进行扩容</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++; //结构性修改计数器加一</span><br><span class="line"></span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)//如果size+1的容量大于数组长度，则需要扩容</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="grow"><a href="#grow" class="headerlink" title="grow"></a>grow</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length; // 旧容量</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 新容量为旧容量的1.5倍</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0) // 新容量小于参数指定容量，修改新容量</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0) // 新容量大于最大容量</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity); //指定新容量</span><br><span class="line">    // 拷贝扩容</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git删除大文件历史记录</title>
      <link href="/blog/2022/04/28/git/%E5%88%A0%E9%99%A4%E5%A4%A7%E6%96%87%E4%BB%B6%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/"/>
      <url>/blog/2022/04/28/git/%E5%88%A0%E9%99%A4%E5%A4%A7%E6%96%87%E4%BB%B6%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>git上传文件后会将文件保存，就算删除后也能在commit中看到，这个工具能将文件从历史中删除，包括commit中的操作记录</p></blockquote><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ul><li>上传了较大的文件，会导致每次拉取项目的时候执行时间比较长</li><li>上传了私密的信息，比如账号密码</li></ul><h1 id="官网地址"><a href="#官网地址" class="headerlink" title="官网地址"></a>官网地址</h1><blockquote><p><a href="https://rtyley.github.io/bfg-repo-cleaner/">https://rtyley.github.io/bfg-repo-cleaner/</a><br>需要先到官网下载jar包</p></blockquote><h1 id="大文件的查询"><a href="#大文件的查询" class="headerlink" title="大文件的查询"></a>大文件的查询</h1><blockquote><p>在项目的目录下，windows系统需要在git bash上执行</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//找出项目中的大文件</span><br><span class="line">git verify-pack -v .git/objects/pack/pack-*.idx | sort -k 3 -g | tail -10</span><br></pre></td></tr></table></figure><p><img src="/blog/img/md/git/delete_history_01.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//查询文件名称</span><br><span class="line"> git rev-list --objects --all | grep 3514e1f287dd0722266a35b05b7a7d10923c99f0</span><br></pre></td></tr></table></figure><p><img src="/blog/img/md/git/delete_history_02.png"></p><h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><h2 id="1-拉取仓库镜像"><a href="#1-拉取仓库镜像" class="headerlink" title="1. 拉取仓库镜像"></a>1. 拉取仓库镜像</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --mirror git://example.com/some-repo.git</span><br></pre></td></tr></table></figure><p><img src="/blog/img/md/git/delete_history_03.png" alt="image"></p><h2 id="2-文件删除"><a href="#2-文件删除" class="headerlink" title="2. 文件删除"></a>2. 文件删除</h2><h3 id="2-1-单个文件"><a href="#2-1-单个文件" class="headerlink" title="2.1 单个文件"></a>2.1 单个文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar bfg-1.14.0.jar --delete-files test.zip  some-repo.git</span><br></pre></td></tr></table></figure><h3 id="2-2-文件夹"><a href="#2-2-文件夹" class="headerlink" title="2.2 文件夹"></a>2.2 文件夹</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar bfg-1.14.0.jar --delete-folders nacos --delete-files nacos  --no-blob-protection  some-repo.git</span><br></pre></td></tr></table></figure><p><img src="/blog/img/md/git/delete_history_04.png" alt="image"><br><img src="/blog/img/md/git/delete_history_05.png" alt="image"></p><h2 id="3-更新仓库"><a href="#3-更新仓库" class="headerlink" title="3. 更新仓库"></a>3. 更新仓库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd some-repo.git</span><br><span class="line">git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="/blog/img/md/git/delete_history_06.png" alt="image"></p><h2 id="4-删除本地仓库，重新拉取代码"><a href="#4-删除本地仓库，重新拉取代码" class="headerlink" title="4. 删除本地仓库，重新拉取代码"></a>4. 删除本地仓库，重新拉取代码</h2><blockquote><p>如果删除文件后，使用原仓库上传，会将删除的文件再次上传。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 常见问题</title>
      <link href="/blog/2022/04/28/Mysql/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2022/04/28/Mysql/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="清空自增主键"><a href="#清空自增主键" class="headerlink" title="清空自增主键"></a>清空自增主键</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET FOREIGN_KEY_CHECKS=0;</span><br><span class="line">TRUNCATE TABLE 表名;</span><br><span class="line">SET FOREIGN_KEY_CHECKS=1;</span><br><span class="line">SELECT  @@FOREIGN_KEY_CHECKS;</span><br></pre></td></tr></table></figure><h1 id="mysql运行报The-server-time-zone-value-‘OÐ¹u±e×¼E±¼a’"><a href="#mysql运行报The-server-time-zone-value-‘OÐ¹u±e×¼E±¼a’" class="headerlink" title="mysql运行报The server time zone value ‘ÖÐ¹ú±ê×¼Ê±¼ä’"></a>mysql运行报The server time zone value ‘ÖÐ¹ú±ê×¼Ê±¼ä’</h1><blockquote><p>is unrecognized or represents more than one time zone的解决方法：<br>    将时区设置为你当前系统时区即可，<br>    因此使用root用户登录mysql,使用以下命令</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show variables like <span class="string">&#x27;%time_zone%&#x27;</span>;</span><br><span class="line"><span class="built_in">set</span> global time_zone=<span class="string">&#x27;+8:00&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="Ubuntu-Server-X64-mysql无法连接"><a href="#Ubuntu-Server-X64-mysql无法连接" class="headerlink" title="Ubuntu Server X64 mysql无法连接"></a>Ubuntu Server X64 mysql无法连接</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/mysql/mysql.conf.d/mysql.cnf</span><br><span class="line">修改bind-address = 0.0.0.0</span><br><span class="line">grant all privileges on *.* to <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 常用操作</title>
      <link href="/blog/2022/04/28/Maven/%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/blog/2022/04/28/Maven/%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mvn dependency:resolve -Dclassifier=sources</span><br><span class="line">或者</span><br><span class="line">mvn dependency:sources</span><br><span class="line">mvn dependency:resolve -Dclassifier=javadoc</span><br><span class="line">命令使用方法：首先进入到相应的pom.xml目录中，然后执行以上命令：</span><br><span class="line">第一个命令是尝试下载在pom.xml中依赖的文件的源代码。</span><br><span class="line">第二个命令：是尝试下载对应的javadocs</span><br></pre></td></tr></table></figure><h1 id="将服务器本地的jar添加到服务器本地仓库"><a href="#将服务器本地的jar添加到服务器本地仓库" class="headerlink" title="将服务器本地的jar添加到服务器本地仓库"></a>将服务器本地的jar添加到服务器本地仓库</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file -DgroupId=com.xxx -DartifactId=xxx -Dversion=1.0  -Dpackaging=jar  -Dfile=xxx1.0.jar</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7对外开放端口</title>
      <link href="/blog/2022/04/28/Linux/firewall/"/>
      <url>/blog/2022/04/28/Linux/firewall/</url>
      
        <content type="html"><![CDATA[<h1 id="查看对外开放的端口状态"><a href="#查看对外开放的端口状态" class="headerlink" title="查看对外开放的端口状态"></a>查看对外开放的端口状态</h1><blockquote><p>查询已开放的端口 netstat -anp<br>查询指定端口是否已开 firewall-cmd –query-port=666/tcp<br>提示 yes，表示开启；no表示未开启。</p></blockquote><h1 id="查看防火墙状态"><a href="#查看防火墙状态" class="headerlink" title="查看防火墙状态"></a>查看防火墙状态</h1><blockquote><p>查看防火墙状态 systemctl status firewalld<br>开启防火墙 systemctl start firewalld<br>关闭防火墙 systemctl stop firewalld<br>开启防火墙 service firewalld start<br>若遇到无法开启<br>先用：systemctl unmask firewalld.service<br>然后：systemctl start firewalld.service</p></blockquote><h1 id="对外开发端口"><a href="#对外开发端口" class="headerlink" title="对外开发端口"></a>对外开发端口</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看想开的端口是否已开：</span></span><br><span class="line">firewall-cmd --query-port=6379/tcp</span><br><span class="line"><span class="comment">#添加指定需要开放的端口：</span></span><br><span class="line">firewall-cmd --add-port=123/tcp --permanent</span><br><span class="line"><span class="comment">#重载入添加的端口：</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="comment">#查询指定端口是否开启成功：</span></span><br><span class="line">firewall-cmd --query-port=123/tcp</span><br><span class="line"><span class="comment">#移除指定端口：</span></span><br><span class="line">firewall-cmd --permanent --remove-port=123/tcp</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vsftpd虚拟用户</title>
      <link href="/blog/2022/04/28/Linux/vsftpd%E8%99%9A%E6%8B%9F%E7%94%A8%E6%88%B7/"/>
      <url>/blog/2022/04/28/Linux/vsftpd%E8%99%9A%E6%8B%9F%E7%94%A8%E6%88%B7/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#关闭selinux</span></span><br><span class="line">vim /etc/selinux/config</span><br><span class="line">关闭防火墙</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disabled firewalld</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"><span class="comment">#安装</span></span><br><span class="line">yum install vsftpd -y</span><br><span class="line"><span class="built_in">cd</span> /etc/vsftpd/</span><br><span class="line"><span class="comment">#创建虚拟用户</span></span><br><span class="line">vim loginusers</span><br><span class="line">    ftp1</span><br><span class="line">    123</span><br><span class="line">    ftp2</span><br><span class="line">    123</span><br><span class="line">db_load -T -t <span class="built_in">hash</span> -f loginusers loginusers.db</span><br><span class="line">chmod 600 loginusers*</span><br><span class="line">vim /etc/pam.d/ckvsftpd</span><br><span class="line">    auth required pam_userdb.so db=/etc/vsftpd/loginusers</span><br><span class="line">    account required pam_userdb.so db=/etc/vsftpd/loginusers</span><br><span class="line">vim /etc/vsftpd/vsftpd.conf</span><br><span class="line">    pam_service_name=ckvsftpd</span><br><span class="line">    guest_enable=YES</span><br><span class="line">    guest_username=ftp</span><br><span class="line">    local_root=/ftp/<span class="variable">$USER</span></span><br><span class="line">    user_sub_token=<span class="variable">$USER</span></span><br><span class="line">    user_config_dir=/etc/vsftpd/conf.d</span><br><span class="line">mkdir /ftp</span><br><span class="line">chgrp ftp /ftp/</span><br><span class="line">chmod g+s /ftp/</span><br><span class="line">mkdir /ftp/ftp&#123;1..2&#125;</span><br><span class="line">mkidr /ftp/ftp2/upload</span><br><span class="line">chown ftp /ftp/ftp2/upload</span><br><span class="line">mkdir /etc/vsftpd/conf.d</span><br><span class="line">vim /etc/vsftpd/conf.d/ftp1</span><br><span class="line">    local_root=&#123;自定义目录&#125;</span><br><span class="line">vim /etc/vsftpd/conf.d/ftp2</span><br><span class="line">    write_enable=YES</span><br><span class="line">    anon_upload_enable=YES</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kong安装</title>
      <link href="/blog/2022/04/28/Kong/%E5%AE%89%E8%A3%85/"/>
      <url>/blog/2022/04/28/Kong/%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="创建网络环境"><a href="#创建网络环境" class="headerlink" title="创建网络环境"></a>创建网络环境</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create kong-net --driver bridge</span><br></pre></td></tr></table></figure><h1 id="安装数据库"><a href="#安装数据库" class="headerlink" title="安装数据库"></a>安装数据库</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name kong-database --network=kong-net -p 5432:5432 -v /home/iot/kong/pgdata:/var/lib/postgresql/data -v /etc/localtime:/etc/localtime:ro -e <span class="string">&quot;POSTGRES_USER=kong&quot;</span> -e <span class="string">&quot;POSTGRES_DB=kong&quot;</span> -e <span class="string">&quot;POSTGRES_PASSWORD=kong&quot;</span> --restart always postgres:9.6</span><br></pre></td></tr></table></figure><h1 id="初始化kong数据库"><a href="#初始化kong数据库" class="headerlink" title="初始化kong数据库"></a>初始化kong数据库</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm --network=kong-net -e <span class="string">&quot;KONG_DATABASE=postgres&quot;</span> -e <span class="string">&quot;KONG_PG_HOST=kong-database&quot;</span> -e <span class="string">&quot;KONG_PG_USER=kong&quot;</span> -e <span class="string">&quot;KONG_PG_PASSWORD=kong&quot;</span> -e <span class="string">&quot;KONG_CASSANDRA_CONTACT_POINTS=kong-database&quot;</span> kong:latest kong migrations bootstrap</span><br></pre></td></tr></table></figure><h1 id="启动kong"><a href="#启动kong" class="headerlink" title="启动kong"></a>启动kong</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name kong --network=kong-net -e <span class="string">&quot;KONG_DATABASE=postgres&quot;</span> -e <span class="string">&quot;KONG_PG_HOST=kong-database&quot;</span> -e <span class="string">&quot;KONG_PG_USER=kong&quot;</span> -e <span class="string">&quot;KONG_PG_PASSWORD=kong&quot;</span> -e <span class="string">&quot;KONG_CASSANDRA_CONTACT_POINTS=kong-database&quot;</span> -e <span class="string">&quot;KONG_PROXY_ACCESS_LOG=/dev/stdout&quot;</span> -e <span class="string">&quot;KONG_ADMIN_ACCESS_LOG=/dev/stdout&quot;</span> -e <span class="string">&quot;KONG_PROXY_ERROR_LOG=/dev/stderr&quot;</span> -e <span class="string">&quot;KONG_ADMIN_ERROR_LOG=/dev/stderr&quot;</span> -e <span class="string">&quot;KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl&quot;</span> -p 80:8000 -p 443:8443 -p 8001:8001 -p 8444:8444 -v /home/iot/kong/nginx.conf:/usr/<span class="built_in">local</span>/kong/nginx.conf -v /home/iot/html:/home/iot/html -v /etc/localtime:/etc/localtime:ro --restart always kong:latest</span><br></pre></td></tr></table></figure><h1 id="初始化konga数据库"><a href="#初始化konga数据库" class="headerlink" title="初始化konga数据库"></a>初始化konga数据库</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm  --network=kong-net pantsel/konga:latest -c prepare -a postgres -u postgresql://kong:kong@kong-database:5432/konga_db</span><br></pre></td></tr></table></figure><h1 id="启动konga"><a href="#启动konga" class="headerlink" title="启动konga"></a>启动konga</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 1337:1337 --network=kong-net -e <span class="string">&quot;KONG_DATABASE=postgres&quot;</span> -e <span class="string">&quot;KONG_PG_HOST=kong-database&quot;</span> -e <span class="string">&quot;KONG_PG_USER=kong&quot;</span> -e <span class="string">&quot;KONG_PG_PASSWORD=kong&quot;</span> -e <span class="string">&quot;KONG_CASSANDRA_CONTACT_POINTS=kong-database&quot;</span> -e <span class="string">&quot;DB_DATABASE=konga_db&quot;</span> -e <span class="string">&quot;KONGA_HOOK_TIMEOUT=120000&quot;</span> -v /etc/localtime:/etc/localtime:ro --name konga pantsel/konga</span><br></pre></td></tr></table></figure><h1 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker pull prom/prometheus</span><br><span class="line"></span><br><span class="line">mkdir /opt/prometheus</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /opt/prometheus/</span><br><span class="line"></span><br><span class="line">vim prometheus.yml</span><br><span class="line"></span><br><span class="line">docker run  -d -p 9090:9090 -v /opt/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml -v /etc/localtime:/etc/localtime:ro prom/prometheus:latest</span><br><span class="line"></span><br><span class="line">docker pull grafana/grafana</span><br><span class="line"></span><br><span class="line">mkdir /opt/grafana-storage</span><br><span class="line"></span><br><span class="line">chmod 777 -R /opt/grafana-storage</span><br><span class="line"></span><br><span class="line">docker run -d -p 3000:3000 --name=grafana -v /opt/grafana-storage:/var/lib/grafana -v /etc/localtime:/etc/localtime:ro grafana/grafana</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kong </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins-pipeline</title>
      <link href="/blog/2022/04/28/Jenkins/pipeline/"/>
      <url>/blog/2022/04/28/Jenkins/pipeline/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line">  agent any</span><br><span class="line">  parameters &#123;</span><br><span class="line">    choice(</span><br><span class="line">      description: <span class="string">&#x27;environment&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;env&#x27;</span>,</span><br><span class="line">      choices: [<span class="string">&#x27;dev&#x27;</span>, <span class="string">&#x27;prod&#x27;</span>]</span><br><span class="line">    )</span><br><span class="line">    string(name: <span class="string">&#x27;gitUrl&#x27;</span>, defaultValue: <span class="string">&#x27;http://192.168.24.55:8888&#x27;</span>, description: <span class="string">&#x27;gitUrl&#x27;</span>)</span><br><span class="line">    string(name: <span class="string">&#x27;credentialsId&#x27;</span>, defaultValue: <span class="string">&#x27;cky_gitlab&#x27;</span>, description: <span class="string">&#x27;credentialsId&#x27;</span>)</span><br><span class="line">    string(name: <span class="string">&#x27;bossVersion&#x27;</span>, defaultValue: <span class="string">&#x27;1.0&#x27;</span>, description: <span class="string">&#x27;boss-version&#x27;</span>)</span><br><span class="line">    booleanParam(name: <span class="string">&#x27;checkout&#x27;</span>, defaultValue: <span class="literal">true</span>, description: <span class="string">&#x27;checkout&#x27;</span>)</span><br><span class="line">    booleanParam(name: <span class="string">&#x27;install&#x27;</span>, defaultValue: <span class="literal">false</span>, description: <span class="string">&#x27;install-all&#x27;</span>)</span><br><span class="line">    booleanParam(name: <span class="string">&#x27;installSystem&#x27;</span>, defaultValue: <span class="literal">false</span>, description: <span class="string">&#x27;install-system&#x27;</span>)</span><br><span class="line">    booleanParam(name: <span class="string">&#x27;gateway&#x27;</span>, defaultValue: <span class="literal">false</span>, description: <span class="string">&#x27;boss-gateway&#x27;</span>)</span><br><span class="line">    booleanParam(name: <span class="string">&#x27;auth&#x27;</span>, defaultValue: <span class="literal">false</span>, description: <span class="string">&#x27;boss-auth&#x27;</span>)</span><br><span class="line">    booleanParam(name: <span class="string">&#x27;system&#x27;</span>, defaultValue: <span class="literal">false</span>, description: <span class="string">&#x27;boss-system&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  tools &#123;</span><br><span class="line">    maven <span class="string">&quot;maven-3.6.3&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  stages &#123;</span><br><span class="line">    stage(<span class="string">&#x27;Build&#x27;</span>) &#123;</span><br><span class="line">      steps&#123;</span><br><span class="line">        script&#123;</span><br><span class="line">          installSh=<span class="string">&quot;mvn clean install -Dmaven.test.skip=true&quot;</span></span><br><span class="line">          <span class="keyword">if</span>( <span class="string">&quot;<span class="variable">$&#123;params.env&#125;</span>&quot;</span> == <span class="string">&#x27;prod&#x27;</span> ) &#123;</span><br><span class="line">            installSh=<span class="string">&quot;mvn clean install -Dmaven.test.skip=true -P prod&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( <span class="string">&quot;<span class="variable">$checkout</span>&quot;</span> == <span class="string">&#x27;true&#x27;</span> ) &#123;</span><br><span class="line">            checkout([<span class="variable">$class</span>: <span class="string">&#x27;GitSCM&#x27;</span>, branches: [[name: <span class="string">&#x27;*/master&#x27;</span>]], doGenerateSubmoduleConfigurations: <span class="literal">false</span>, extensions: [[<span class="variable">$class</span>: <span class="string">&#x27;RelativeTargetDirectory&#x27;</span>, relativeTargetDir: <span class="string">&#x27;boss-core&#x27;</span>]], submoduleCfg: [], userRemoteConfigs: [[credentialsId: <span class="string">&quot;<span class="variable">$credentialsId</span>&quot;</span>, url: <span class="string">&#x27;$&#123;gitUrl&#125;/gitlab/boss/newboss/boss-core.git&#x27;</span>]]])</span><br><span class="line">            checkout([<span class="variable">$class</span>: <span class="string">&#x27;GitSCM&#x27;</span>, branches: [[name: <span class="string">&#x27;*/master&#x27;</span>]], doGenerateSubmoduleConfigurations: <span class="literal">false</span>, extensions: [[<span class="variable">$class</span>: <span class="string">&#x27;RelativeTargetDirectory&#x27;</span>, relativeTargetDir: <span class="string">&#x27;boss-api&#x27;</span>]], submoduleCfg: [], userRemoteConfigs: [[credentialsId: <span class="string">&quot;<span class="variable">$credentialsId</span>&quot;</span>, url: <span class="string">&#x27;$&#123;gitUrl&#125;/gitlab/boss/newboss/boss-api&#x27;</span>]]])</span><br><span class="line">            checkout([<span class="variable">$class</span>: <span class="string">&#x27;GitSCM&#x27;</span>, branches: [[name: <span class="string">&#x27;*/master&#x27;</span>]], doGenerateSubmoduleConfigurations: <span class="literal">false</span>, extensions: [[<span class="variable">$class</span>: <span class="string">&#x27;RelativeTargetDirectory&#x27;</span>, relativeTargetDir: <span class="string">&#x27;boss-system&#x27;</span>]], submoduleCfg: [], userRemoteConfigs: [[credentialsId: <span class="string">&quot;<span class="variable">$credentialsId</span>&quot;</span>, url: <span class="string">&#x27;$&#123;gitUrl&#125;/gitlab/boss/newboss-modules/boss-system&#x27;</span>]]])</span><br><span class="line">            checkout([<span class="variable">$class</span>: <span class="string">&#x27;GitSCM&#x27;</span>, branches: [[name: <span class="string">&#x27;*/master&#x27;</span>]], doGenerateSubmoduleConfigurations: <span class="literal">false</span>, extensions: [[<span class="variable">$class</span>: <span class="string">&#x27;RelativeTargetDirectory&#x27;</span>, relativeTargetDir: <span class="string">&#x27;boss-common&#x27;</span>]], submoduleCfg: [], userRemoteConfigs: [[credentialsId: <span class="string">&quot;<span class="variable">$credentialsId</span>&quot;</span>, url: <span class="string">&#x27;$&#123;gitUrl&#125;/gitlab/boss/newboss/boss-common&#x27;</span>]]])</span><br><span class="line">            checkout([<span class="variable">$class</span>: <span class="string">&#x27;GitSCM&#x27;</span>, branches: [[name: <span class="string">&#x27;*/master&#x27;</span>]], doGenerateSubmoduleConfigurations: <span class="literal">false</span>, extensions: [[<span class="variable">$class</span>: <span class="string">&#x27;RelativeTargetDirectory&#x27;</span>, relativeTargetDir: <span class="string">&#x27;boss-auth&#x27;</span>]], submoduleCfg: [], userRemoteConfigs: [[credentialsId: <span class="string">&quot;<span class="variable">$credentialsId</span>&quot;</span>, url: <span class="string">&#x27;$&#123;gitUrl&#125;/gitlab/boss/newboss/boss-auth&#x27;</span>]]])</span><br><span class="line">            checkout([<span class="variable">$class</span>: <span class="string">&#x27;GitSCM&#x27;</span>, branches: [[name: <span class="string">&#x27;*/master&#x27;</span>]], doGenerateSubmoduleConfigurations: <span class="literal">false</span>, extensions: [[<span class="variable">$class</span>: <span class="string">&#x27;RelativeTargetDirectory&#x27;</span>, relativeTargetDir: <span class="string">&#x27;boss-gateway&#x27;</span>]], submoduleCfg: [], userRemoteConfigs: [[credentialsId: <span class="string">&quot;<span class="variable">$credentialsId</span>&quot;</span>, url: <span class="string">&#x27;$&#123;gitUrl&#125;/gitlab/boss/newboss/boss-gateway&#x27;</span>]]])</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>( <span class="string">&quot;<span class="variable">$install</span>&quot;</span> == <span class="string">&#x27;true&#x27;</span> ) &#123;</span><br><span class="line">            dir(<span class="string">&#x27;boss&#x27;</span>) &#123;</span><br><span class="line">                sh <span class="string">&quot;<span class="variable">$installSh</span>&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>( <span class="string">&quot;<span class="variable">$installSystem</span>&quot;</span> == <span class="string">&#x27;true&#x27;</span> ) &#123;</span><br><span class="line">                dir(<span class="string">&#x27;boss-system&#x27;</span>) &#123;</span><br><span class="line">                    sh <span class="string">&quot;<span class="variable">$installSh</span>&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stage(<span class="string">&#x27;publish&#x27;</span>) &#123;</span><br><span class="line">      parallel &#123;</span><br><span class="line">        stage(<span class="string">&#x27;boss-gateway&#x27;</span>) &#123;</span><br><span class="line">          steps &#123;</span><br><span class="line">            script&#123;</span><br><span class="line">              <span class="keyword">if</span> ( <span class="string">&quot;<span class="variable">$gateway</span>&quot;</span> == <span class="string">&#x27;true&#x27;</span> ) &#123;</span><br><span class="line">                dir(<span class="string">&#x27;boss-gateway/src/main/docker&#x27;</span>) &#123;</span><br><span class="line">                  try &#123;sh <span class="string">&quot;docker stop boss-gateway&quot;</span>&#125;catch (exc) &#123;<span class="built_in">echo</span> <span class="string">&quot;The container doesn&#x27;t running&quot;</span>&#125;</span><br><span class="line">                  try &#123;sh <span class="string">&quot;docker rm boss-gateway&quot;</span>&#125;catch (exc) &#123;<span class="built_in">echo</span> <span class="string">&quot;The container doesn&#x27;t exist&quot;</span>&#125;</span><br><span class="line">                  try &#123;sh <span class="string">&quot;docker rmi boss-gateway:<span class="variable">$&#123;bossVersion&#125;</span>&quot;</span>&#125;catch (exc) &#123;<span class="built_in">echo</span> <span class="string">&quot;The image doesn&#x27;t exist&quot;</span>&#125;</span><br><span class="line">                  </span><br><span class="line">                  sh <span class="string">&quot;docker build -t boss-gateway:<span class="variable">$&#123;bossVersion&#125;</span> . &amp;&amp; docker run -d &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;-v /home/boss/logs/boss-gateway:/home/boss/logs/boss-gateway &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;--name boss-gateway &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;--restart always &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;--network host &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;boss-gateway:<span class="variable">$&#123;bossVersion&#125;</span>&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;boss-auth&#x27;</span>) &#123;</span><br><span class="line">          steps &#123;</span><br><span class="line">            script&#123;</span><br><span class="line">              <span class="keyword">if</span> ( <span class="string">&quot;<span class="variable">$auth</span>&quot;</span> == <span class="string">&#x27;true&#x27;</span> ) &#123;</span><br><span class="line">                dir(<span class="string">&#x27;boss-auth/src/main/docker&#x27;</span>) &#123;</span><br><span class="line">                  try &#123;sh <span class="string">&quot;docker stop boss-auth&quot;</span>&#125;catch (exc) &#123;<span class="built_in">echo</span> <span class="string">&quot;The container doesn&#x27;t running&quot;</span>&#125;</span><br><span class="line">                  try &#123;sh <span class="string">&quot;docker rm boss-auth&quot;</span>&#125;catch (exc) &#123;<span class="built_in">echo</span> <span class="string">&quot;The container doesn&#x27;t exist&quot;</span>&#125;</span><br><span class="line">                  try &#123;sh <span class="string">&quot;docker rmi boss-auth:<span class="variable">$&#123;bossVersion&#125;</span>&quot;</span>&#125;catch (exc) &#123;<span class="built_in">echo</span> <span class="string">&quot;The image doesn&#x27;t exist&quot;</span>&#125;</span><br><span class="line">                  </span><br><span class="line">                  sh <span class="string">&quot;docker build -t boss-auth:<span class="variable">$&#123;bossVersion&#125;</span> . &amp;&amp; docker run -d &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;-v /home/boss/logs/boss-auth:/home/boss/logs/boss-auth &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;--name boss-auth &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;--restart always &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;--network host &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;boss-auth:<span class="variable">$&#123;bossVersion&#125;</span>&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;boss-system&#x27;</span>) &#123;</span><br><span class="line">          steps &#123;</span><br><span class="line">            script&#123;</span><br><span class="line">              <span class="keyword">if</span> ( <span class="string">&quot;<span class="variable">$system</span>&quot;</span> == <span class="string">&#x27;true&#x27;</span> ) &#123;</span><br><span class="line">                dir(<span class="string">&#x27;boss-system/src/main/docker&#x27;</span>) &#123;</span><br><span class="line">                  try &#123;sh <span class="string">&quot;docker stop boss-system&quot;</span>&#125;catch (exc) &#123;<span class="built_in">echo</span> <span class="string">&quot;The container doesn&#x27;t running&quot;</span>&#125;</span><br><span class="line">                  try &#123;sh <span class="string">&quot;docker rm boss-system&quot;</span>&#125;catch (exc) &#123;<span class="built_in">echo</span> <span class="string">&quot;The container doesn&#x27;t exist&quot;</span>&#125;</span><br><span class="line">                  try &#123;sh <span class="string">&quot;docker rmi boss-system:<span class="variable">$&#123;bossVersion&#125;</span>&quot;</span>&#125;catch (exc) &#123;<span class="built_in">echo</span> <span class="string">&quot;The image doesn&#x27;t exist&quot;</span>&#125;</span><br><span class="line">                  </span><br><span class="line">                  sh <span class="string">&quot;docker build -t boss-system:<span class="variable">$&#123;bossVersion&#125;</span> . &amp;&amp; docker run -d &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;-v /home/boss/logs/boss-system:/home/boss/logs/boss-system &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;-v /home/boss/avatar:/home/boss/avatar &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;-v /home/boss/file/user:/home/boss/file/user &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;--name boss-system &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;--restart always &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;--network host &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;boss-system:<span class="variable">$&#123;bossVersion&#125;</span>&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins安装</title>
      <link href="/blog/2022/04/28/Jenkins/%E5%AE%89%E8%A3%85/"/>
      <url>/blog/2022/04/28/Jenkins/%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="官网地址"><a href="#官网地址" class="headerlink" title="官网地址"></a>官网地址</h1><blockquote><p><a href="https://jenkins.io/zh/">https://jenkins.io/zh/</a></p></blockquote><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><img src="/blog/img/md/Jenkins/01.png"><br><img src="/blog/img/md/Jenkins/02.png"></p><ol><li>CMD中执行命令：java -jar jenkins.war（–httpPort=8080）</li><li>浏览<a href="http://localhost:8080并等到*Unlock">http://localhost:8080并等到*Unlock</a> Jenkins*页面出现。</li><li>后台启动执行命令：nohup java -jar jenkins.war –httpPort=18080 &gt;/opt/jenkins/start.log  &amp;</li></ol><h3 id="可能会出现以下问题"><a href="#可能会出现以下问题" class="headerlink" title="可能会出现以下问题"></a>可能会出现以下问题</h3><p><img src="/blog/img/md/Jenkins/03.png"></p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p><img src="/blog/img/md/Jenkins/04.png"><br><img src="/blog/img/md/Jenkins/05.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://mirror.xmission.com/jenkins/updates/update-center.json</span><br></pre></td></tr></table></figure><p>重启tomcat就行了</p><h2 id="解锁-Jenkins"><a href="#解锁-Jenkins" class="headerlink" title="解锁 Jenkins"></a>解锁 Jenkins</h2><p><img src="/blog/img/md/Jenkins/06.png"></p><p><img src="/blog/img/md/Jenkins/07.png"></p><h2 id="自定义jenkins插件"><a href="#自定义jenkins插件" class="headerlink" title="自定义jenkins插件"></a>自定义jenkins插件</h2><p>选择：安装建议的插件</p><p>安装额外插件</p><p><img src="/blog/img/md/Jenkins/08.png"></p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p><img src="/blog/img/md/Jenkins/09.png"></p><p><img src="/blog/img/md/Jenkins/10.png"></p><p><img src="/blog/img/md/Jenkins/11.png"></p><h2 id="配置自动化部署"><a href="#配置自动化部署" class="headerlink" title="配置自动化部署"></a>配置自动化部署</h2><h3 id="打包配置"><a href="#打包配置" class="headerlink" title="打包配置"></a>打包配置</h3><p><img src="/blog/img/md/Jenkins/12.png"></p><p><img src="/blog/img/md/Jenkins/13.png"></p><p><img src="/blog/img/md/Jenkins/14.png"></p><p><img src="/blog/img/md/Jenkins/15.png"></p><p><img src="/blog/img/md/Jenkins/16.png"></p><p><img src="/blog/img/md/Jenkins/17.png"></p><h3 id="发布配置"><a href="#发布配置" class="headerlink" title="发布配置"></a>发布配置</h3><p>配置tomcat<br><img src="/blog/img/md/Jenkins/18.png"></p><p><img src="/blog/img/md/Jenkins/19.png"></p><p><img src="/blog/img/md/Jenkins/20.png"></p><p>配置触发器</p><p><img src="/blog/img/md/Jenkins/21.png"></p><p>只需访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8081/job/HardwareAlliance/build?token=MY_TOKEN</span><br></pre></td></tr></table></figure><p>便会触发构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X post -v -u admin:e0eae93ad7e74f7ab76545bee47793d1 http://localhost:8081/job/HardwareAlliance/build?token=MY_TOKEN</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stream</title>
      <link href="/blog/2022/04/28/Java/Stream/"/>
      <url>/blog/2022/04/28/Java/Stream/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一、 Stream 的操作步骤</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1. 创建 Stream</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2. 中间操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3. 终止操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStreamAPI1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">List&lt;Employee&gt; emps = Arrays.asList(</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">102</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">59</span>, <span class="number">6666.66</span>),</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">101</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">9999.99</span>),</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">103</span>, <span class="string">&quot;王五&quot;</span>, <span class="number">28</span>, <span class="number">3333.33</span>),</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">&quot;赵六&quot;</span>, <span class="number">8</span>, <span class="number">7777.77</span>),</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">&quot;赵六&quot;</span>, <span class="number">8</span>, <span class="number">7777.77</span>),</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">&quot;赵六&quot;</span>, <span class="number">8</span>, <span class="number">7777.77</span>),</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">105</span>, <span class="string">&quot;田七&quot;</span>, <span class="number">38</span>, <span class="number">5555.55</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 中间操作</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">映射</span></span><br><span class="line"><span class="comment">map——接收 Lambda ， 将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</span></span><br><span class="line"><span class="comment">flatMap——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">Stream&lt;String&gt; str = emps.stream()</span><br><span class="line">.map((e) -&gt; e.getName());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;-------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; strList = Arrays.asList(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>, <span class="string">&quot;ddd&quot;</span>, <span class="string">&quot;eee&quot;</span>);</span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; stream = strList.stream()</span><br><span class="line">   .map(String::toUpperCase);</span><br><span class="line"></span><br><span class="line">stream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">Stream&lt;Stream&lt;Character&gt;&gt; stream2 = strList.stream()</span><br><span class="line">   .map(TestStreamAPI1::filterCharacter);</span><br><span class="line"></span><br><span class="line">stream2.forEach((sm) -&gt; &#123;</span><br><span class="line">sm.forEach(System.out::println);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;---------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">Stream&lt;Character&gt; stream3 = strList.stream()</span><br><span class="line">   .flatMap(TestStreamAPI1::filterCharacter);</span><br><span class="line"></span><br><span class="line">stream3.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title">filterCharacter</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">List&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Character ch : str.toCharArray()) &#123;</span><br><span class="line">list.add(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> list.stream();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sorted()——自然排序</span></span><br><span class="line"><span class="comment">sorted(Comparator com)——定制排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">emps.stream()</span><br><span class="line">.map(Employee::getName)</span><br><span class="line">.sorted()</span><br><span class="line">.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">emps.stream()</span><br><span class="line">.sorted((x, y) -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span>(x.getAge() == y.getAge())&#123;</span><br><span class="line"><span class="keyword">return</span> x.getName().compareTo(y.getName());</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> Integer.compare(x.getAge(), y.getAge());</span><br><span class="line">&#125;</span><br><span class="line">&#125;).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一、 Stream 的操作步骤</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1. 创建 Stream</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2. 中间操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3. 终止操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStreamAPI2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">List&lt;Employee&gt; emps = Arrays.asList(</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">102</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">59</span>, <span class="number">6666.66</span>, Status.BUSY),</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">101</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">9999.99</span>, Status.FREE),</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">103</span>, <span class="string">&quot;王五&quot;</span>, <span class="number">28</span>, <span class="number">3333.33</span>, Status.VOCATION),</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">&quot;赵六&quot;</span>, <span class="number">8</span>, <span class="number">7777.77</span>, Status.BUSY),</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">&quot;赵六&quot;</span>, <span class="number">8</span>, <span class="number">7777.77</span>, Status.FREE),</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">&quot;赵六&quot;</span>, <span class="number">8</span>, <span class="number">7777.77</span>, Status.FREE),</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">105</span>, <span class="string">&quot;田七&quot;</span>, <span class="number">38</span>, <span class="number">5555.55</span>, Status.BUSY)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 终止操作</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">allMatch——检查是否匹配所有元素</span></span><br><span class="line"><span class="comment">anyMatch——检查是否至少匹配一个元素</span></span><br><span class="line"><span class="comment">noneMatch——检查是否没有匹配的元素</span></span><br><span class="line"><span class="comment">findFirst——返回第一个元素</span></span><br><span class="line"><span class="comment">findAny——返回当前流中的任意元素</span></span><br><span class="line"><span class="comment">count——返回流中元素的总个数</span></span><br><span class="line"><span class="comment">max——返回流中最大值</span></span><br><span class="line"><span class="comment">min——返回流中最小值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> bl = emps.stream()</span><br><span class="line">.allMatch((e) -&gt; e.getStatus().equals(Status.BUSY));</span><br><span class="line"></span><br><span class="line">System.out.println(bl);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> bl1 = emps.stream()</span><br><span class="line">.anyMatch((e) -&gt; e.getStatus().equals(Status.BUSY));</span><br><span class="line"></span><br><span class="line">System.out.println(bl1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> bl2 = emps.stream()</span><br><span class="line">.noneMatch((e) -&gt; e.getStatus().equals(Status.BUSY));</span><br><span class="line"></span><br><span class="line">System.out.println(bl2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">Optional&lt;Employee&gt; op = emps.stream()</span><br><span class="line">.sorted((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()))</span><br><span class="line">.findFirst();</span><br><span class="line"></span><br><span class="line">System.out.println(op.get());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">Optional&lt;Employee&gt; op2 = emps.parallelStream()</span><br><span class="line">.filter((e) -&gt; e.getStatus().equals(Status.FREE))</span><br><span class="line">.findAny();</span><br><span class="line"></span><br><span class="line">System.out.println(op2.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> count = emps.stream()</span><br><span class="line"> .filter((e) -&gt; e.getStatus().equals(Status.FREE))</span><br><span class="line"> .count();</span><br><span class="line"></span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line">Optional&lt;Double&gt; op = emps.stream()</span><br><span class="line">.map(Employee::getSalary)</span><br><span class="line">.max(Double::compare);</span><br><span class="line"></span><br><span class="line">System.out.println(op.get());</span><br><span class="line"></span><br><span class="line">Optional&lt;Employee&gt; op2 = emps.stream()</span><br><span class="line">.min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));</span><br><span class="line"></span><br><span class="line">System.out.println(op2.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：流进行了终止操作后，不能再次使用</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">Stream&lt;Employee&gt; stream = emps.stream()</span><br><span class="line"> .filter((e) -&gt; e.getStatus().equals(Status.FREE));</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> count = stream.count();</span><br><span class="line"></span><br><span class="line">stream.map(Employee::getSalary)</span><br><span class="line">.max(Double::compare);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStreamAPI3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">List&lt;Employee&gt; emps = Arrays.asList(</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">102</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">79</span>, <span class="number">6666.66</span>, Status.BUSY),</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">101</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">9999.99</span>, Status.FREE),</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">103</span>, <span class="string">&quot;王五&quot;</span>, <span class="number">28</span>, <span class="number">3333.33</span>, Status.VOCATION),</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">&quot;赵六&quot;</span>, <span class="number">8</span>, <span class="number">7777.77</span>, Status.BUSY),</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">&quot;赵六&quot;</span>, <span class="number">8</span>, <span class="number">7777.77</span>, Status.FREE),</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">&quot;赵六&quot;</span>, <span class="number">8</span>, <span class="number">7777.77</span>, Status.FREE),</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">105</span>, <span class="string">&quot;田七&quot;</span>, <span class="number">38</span>, <span class="number">5555.55</span>, Status.BUSY)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 终止操作</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">归约</span></span><br><span class="line"><span class="comment">reduce(T identity, BinaryOperator) / reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">Integer sum = list.stream()</span><br><span class="line">.reduce(<span class="number">0</span>, (x, y) -&gt; x + y);</span><br><span class="line"></span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;----------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">Optional&lt;Double&gt; op = emps.stream()</span><br><span class="line">.map(Employee::getSalary)</span><br><span class="line">.reduce(Double::sum);</span><br><span class="line"></span><br><span class="line">System.out.println(op.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需求：搜索名字中 “六” 出现的次数</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">Optional&lt;Integer&gt; sum = emps.stream()</span><br><span class="line">.map(Employee::getName)</span><br><span class="line">.flatMap(TestStreamAPI1::filterCharacter)</span><br><span class="line">.map((ch) -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span>(ch.equals(<span class="string">&#x27;六&#x27;</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;).reduce(Integer::sum);</span><br><span class="line"></span><br><span class="line">System.out.println(sum.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//collect——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;String&gt; list = emps.stream()</span><br><span class="line">.map(Employee::getName)</span><br><span class="line">.collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">list.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; set = emps.stream()</span><br><span class="line">.map(Employee::getName)</span><br><span class="line">.collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">set.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">HashSet&lt;String&gt; hs = emps.stream()</span><br><span class="line">.map(Employee::getName)</span><br><span class="line">.collect(Collectors.toCollection(HashSet::<span class="keyword">new</span>));</span><br><span class="line"></span><br><span class="line">hs.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">Optional&lt;Double&gt; max = emps.stream()</span><br><span class="line">.map(Employee::getSalary)</span><br><span class="line">.collect(Collectors.maxBy(Double::compare));</span><br><span class="line"></span><br><span class="line">System.out.println(max.get());</span><br><span class="line"></span><br><span class="line">Optional&lt;Employee&gt; op = emps.stream()</span><br><span class="line">.collect(Collectors.minBy((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())));</span><br><span class="line"></span><br><span class="line">System.out.println(op.get());</span><br><span class="line"></span><br><span class="line">Double sum = emps.stream()</span><br><span class="line">.collect(Collectors.summingDouble(Employee::getSalary));</span><br><span class="line"></span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line">Double avg = emps.stream()</span><br><span class="line">.collect(Collectors.averagingDouble(Employee::getSalary));</span><br><span class="line"></span><br><span class="line">System.out.println(avg);</span><br><span class="line"></span><br><span class="line">Long count = emps.stream()</span><br><span class="line">.collect(Collectors.counting());</span><br><span class="line"></span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;--------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">DoubleSummaryStatistics dss = emps.stream()</span><br><span class="line">.collect(Collectors.summarizingDouble(Employee::getSalary));</span><br><span class="line"></span><br><span class="line">System.out.println(dss.getMax());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分组</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">Map&lt;Status, List&lt;Employee&gt;&gt; map = emps.stream()</span><br><span class="line">.collect(Collectors.groupingBy(Employee::getStatus));</span><br><span class="line"></span><br><span class="line">System.out.println(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多级分组</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">Map&lt;Status, Map&lt;String, List&lt;Employee&gt;&gt;&gt; map = emps.stream()</span><br><span class="line">.collect(Collectors.groupingBy(Employee::getStatus, Collectors.groupingBy((e) -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span>(e.getAge() &gt;= <span class="number">60</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;老年&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(e.getAge() &gt;= <span class="number">35</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;中年&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;成年&quot;</span>;</span><br><span class="line">&#125;)));</span><br><span class="line"></span><br><span class="line">System.out.println(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分区</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">Map&lt;Boolean, List&lt;Employee&gt;&gt; map = emps.stream()</span><br><span class="line">.collect(Collectors.partitioningBy((e) -&gt; e.getSalary() &gt;= <span class="number">5000</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">String str = emps.stream()</span><br><span class="line">.map(Employee::getName)</span><br><span class="line">.collect(Collectors.joining(<span class="string">&quot;,&quot;</span> , <span class="string">&quot;----&quot;</span>, <span class="string">&quot;----&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span></span>&#123;</span><br><span class="line">Optional&lt;Double&gt; sum = emps.stream()</span><br><span class="line">.map(Employee::getSalary)</span><br><span class="line">.collect(Collectors.reducing(Double::sum));</span><br><span class="line"></span><br><span class="line">System.out.println(sum.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity基本流程</title>
      <link href="/blog/2022/04/28/Spring/SpringSecurity/%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/"/>
      <url>/blog/2022/04/28/Spring/SpringSecurity/%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h1><p><img src="/blog/img/md/Java/01.png"><br><img src="/blog/img/md/Java/06.png"></p><h2 id="FilterSecurityInterceptor"><a href="#FilterSecurityInterceptor" class="headerlink" title="FilterSecurityInterceptor"></a>FilterSecurityInterceptor</h2><blockquote><p>过滤链的最后一条</p></blockquote><p><img src="/blog/img/md/Java/02.png"></p><h2 id="ExceptionTranslationFilter"><a href="#ExceptionTranslationFilter" class="headerlink" title="ExceptionTranslationFilter"></a>ExceptionTranslationFilter</h2><blockquote><p>异常捕获，登录失败则跳转到这里</p></blockquote><p><img src="/blog/img/md/Java/03.png"></p><h2 id="UsernamePasswordAuthenticationFilter"><a href="#UsernamePasswordAuthenticationFilter" class="headerlink" title="UsernamePasswordAuthenticationFilter"></a>UsernamePasswordAuthenticationFilter</h2><blockquote><p>身份认证</p></blockquote><p><img src="/blog/img/md/Java/04.png"></p><h2 id="UserDetailsService"><a href="#UserDetailsService" class="headerlink" title="UserDetailsService"></a>UserDetailsService</h2><blockquote><p>接口 实现这个接口 通过userId获取密码权限等信息</p></blockquote><p><img src="/blog/img/md/Java/05.png"></p><h2 id="PasswordEncoder"><a href="#PasswordEncoder" class="headerlink" title="PasswordEncoder"></a>PasswordEncoder</h2><blockquote><p>接口 配置后可修改密码匹配规则和密码加密</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda</title>
      <link href="/blog/2022/04/28/Java/Lambda/"/>
      <url>/blog/2022/04/28/Java/Lambda/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*java8内置的四大核心函数式接口</span></span><br><span class="line"><span class="comment">Consumer&lt;T&gt; :消费型接口</span></span><br><span class="line"><span class="comment">    void accept(T t);</span></span><br><span class="line"><span class="comment">Supplier&lt;T&gt; :供给型接口</span></span><br><span class="line"><span class="comment">    T get();</span></span><br><span class="line"><span class="comment">Function&lt;T,R&gt;:函数型接口</span></span><br><span class="line"><span class="comment">    R apply(T t);</span></span><br><span class="line"><span class="comment">Predicate&lt;T&gt;:断言型接口</span></span><br><span class="line"><span class="comment">    boolean test(T t);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Predicate&lt;T&gt;:断言型接口</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list = filterStr(Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;atguigu&quot;</span>, <span class="string">&quot;lambda&quot;</span>, <span class="string">&quot;www&quot;</span>),</span><br><span class="line">            (str) -&gt; str.length() &gt; <span class="number">3</span>);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将满足条件的字符串加入到集合中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">filterStr</span><span class="params">(List&lt;String&gt; list, Predicate&lt;String&gt; pre)</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.test(s))&#123;</span><br><span class="line">            strList.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function&lt;T,R&gt;:函数型接口</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s = strHandler(<span class="string">&quot;abcdefg&quot;</span>, (str) -&gt; str.trim().substring(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">strHandler</span><span class="params">(String str, Function&lt;String,String&gt; fun)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String apply = fun.apply(str);</span><br><span class="line">    <span class="keyword">return</span> apply;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Supplier&lt;T&gt; :供给型接口</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; numList = getNumList(<span class="number">10</span>, () -&gt; (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>));</span><br><span class="line">    numList.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产生指定个整数放入集合中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNumList</span><span class="params">(<span class="keyword">int</span> num, Supplier&lt;Integer&gt; sup)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        Integer integer = sup.get();</span><br><span class="line">        list.add(integer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Consumer&lt;T&gt; :消费型接口</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">  happy(<span class="number">10000</span>,(x) -&gt; System.out.println(<span class="string">&quot;消费了&quot;</span> + x + <span class="string">&quot;元&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happy</span><span class="params">(<span class="keyword">double</span> money, Consumer&lt;Double&gt; con)</span></span>&#123;</span><br><span class="line">    con.accept(money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OAuth2.0源码分析</title>
      <link href="/blog/2022/04/28/Java/OAuth2.0/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/blog/2022/04/28/Java/OAuth2.0/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="获取code"><a href="#获取code" class="headerlink" title="获取code"></a>获取code</h2><blockquote><p><a href="http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code">http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code</a></p></blockquote><ol><li><p>访问AuthorizationEndPoint中的/oauth/authorize<br/><br>里面会判断client信息和用户信息，如果user没有Authentication，则会报错，跳转到ExceptionTranslationFilter类中，请求转发到/login路径，并将现请求路径存储到session的saverequest中。</p><blockquote><p>AuthorizationEndPoint（authorize）-&gt;ExceptionTranslationFilter（handleSpringSecurityException-&gt;sendStartAuthentication-&gt; 请求重定向到/login authenticationEntryPoint.commence）<br>requestCache的常用的实现类是HttpSessionRequestCache</p></blockquote></li><li><p>post请求/login路径<br/><br>按照FilterChainProxy的filter链运行到UsernamePasswordAuthenticationFilter，验证通过后执行successHandler.onAuthenticationSuccess(request, response, authResult)，获取session中的savedrequest，重定向到原先的地址/oauth/authorize，并附带完整请求参数。</p><blockquote><p>SavedRequestAwareAuthenticationSuccessHandler </p></blockquote></li><li><p>第二次请求/oauth/authorize<br/><br>请求中携带了Authentication的session，系统验证通过，生成授权码，存储在InMemoryAuthorizationCodeServices中的concurrenthashmap中，且返回给请求参数中的redirect_uri</p></li></ol><h2 id="获取token"><a href="#获取token" class="headerlink" title="获取token"></a>获取token</h2><blockquote><p><a href="http://client:secret@localhost:8080/oauth/token?grant_type=authorization_code&amp;code=%E8%8E%B7%E5%8F%96%E7%9A%84code">http://client:secret@localhost:8080/oauth/token?grant_type=authorization_code&amp;code=获取的code</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> OAuth </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK命令</title>
      <link href="/blog/2022/04/28/Java/Jdk%E5%91%BD%E4%BB%A4/"/>
      <url>/blog/2022/04/28/Java/Jdk%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="jps-查看本机java进程信息"><a href="#jps-查看本机java进程信息" class="headerlink" title="jps 查看本机java进程信息"></a>jps 查看本机java进程信息</h1><blockquote><p>显示当前所有java进程pid的命令，我们可以通过这个命令来查看到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），不过jps有个缺点是只能显示当前用户的进程id，要显示其他用户的还只能用linux的ps命令。</p></blockquote><h2 id="jps-l"><a href="#jps-l" class="headerlink" title="jps -l"></a>jps -l</h2><blockquote><p>输出应用程序main.class的完整package名或者应用程序jar文件完整路径名</p></blockquote><h2 id="jps-v"><a href="#jps-v" class="headerlink" title="jps -v"></a>jps -v</h2><blockquote><p>输出传递给JVM的参数</p></blockquote><h2 id="jps失效"><a href="#jps失效" class="headerlink" title="jps失效"></a>jps失效</h2><blockquote><p>我们在定位问题过程会遇到这样一种情况，用jps查看不到进程id，用ps -ef | grep java却能看到启动的java进程。<br>要解释这种现象，先来了解下jps的实现机制：<br>java程序启动后，会在目录/tmp/hsperfdata_{userName}/下生成几个文件，文件名就是java进程的pid，因此jps列出进程id就是把这个目录下的文件名列一下而已，至于系统参数，则是读取文件中的内容。<br>我们来思考下：如果由于磁盘满了，无法创建这些文件，或者用户对这些文件没有读的权限。又或者因为某种原因这些文件或者目录被清除，出现以上这些情况，就会导致jps命令失效。<br>如果jps命令失效，而我们又要获取pid，还可以使用以下两种方法：</p><ol><li>top | grep java</li><li>ps -ef | grep java</li></ol></blockquote><h1 id="jstack-打印线程的栈信息，制作线程dump文件"><a href="#jstack-打印线程的栈信息，制作线程dump文件" class="headerlink" title="jstack 打印线程的栈信息，制作线程dump文件"></a>jstack 打印线程的栈信息，制作线程dump文件</h1><blockquote><p>主要用于生成指定进程当前时刻的线程快照，线程快照是当前java虚拟机每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是用于定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致长时间等待。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [pid]</span><br></pre></td></tr></table></figure><h1 id="jmap-打印内存映射，制作堆dump文件"><a href="#jmap-打印内存映射，制作堆dump文件" class="headerlink" title="jmap 打印内存映射，制作堆dump文件"></a>jmap 打印内存映射，制作堆dump文件</h1><blockquote><p>主要用于打印指定java进程的共享对象内存映射或堆内存细节。<br>堆Dump是反映堆使用情况的内存镜像，其中主要包括系统信息、虚拟机属性、完整的线程Dump、所有类和对象的状态等。一般在内存不足，GC异常等情况下，我们会去怀疑内存泄漏，这个时候就会去打印堆Dump。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打印的信息分别为：共享对象的起始地址、映射大小、共享对象路径的全程。</span></span><br><span class="line">jmap [pid]</span><br></pre></td></tr></table></figure><h2 id="jmap-heap-pid-查看堆使用情况"><a href="#jmap-heap-pid-查看堆使用情况" class="headerlink" title="jmap -heap [pid] 查看堆使用情况"></a>jmap -heap [pid] 查看堆使用情况</h2><p><img src="/blog/img/md/Java/07.png" alt="图1"></p><h2 id="jmap-histo-pid-查看堆中对象数量和大小"><a href="#jmap-histo-pid-查看堆中对象数量和大小" class="headerlink" title="jmap -histo [pid] 查看堆中对象数量和大小"></a>jmap -histo [pid] 查看堆中对象数量和大小</h2><blockquote><p>打印的信息分别是：序列号、Class实例的数量、内存的占用、类限定名<br>如果是内部类，类名的开头会加上*，如果加上live子参数的话，如jmap -histo：live pid，这个命名会触发一次FUll GC，只统计存活对象</p></blockquote><h2 id="jmap-dump-format-b-file-heapdump-pid-将内存使用的详细情况输出到文件"><a href="#jmap-dump-format-b-file-heapdump-pid-将内存使用的详细情况输出到文件" class="headerlink" title="jmap -dump:format=b,file=heapdump [pid] 将内存使用的详细情况输出到文件"></a>jmap -dump:format=b,file=heapdump [pid] 将内存使用的详细情况输出到文件</h2><blockquote><p>然后使用jhat命令查看该文件：jhat -port 4000 文件名 ，在浏览器中访问http:localhost:4000/<br>总结：<br>该命令适用的场景是程序内存不足或者GC频繁，这时候很可能是内存泄漏。通过以上命令查看堆使用情况、大量对象被持续引用等情况。</p></blockquote><h1 id="jstat-性能监控工具"><a href="#jstat-性能监控工具" class="headerlink" title="jstat 性能监控工具"></a>jstat 性能监控工具</h1><blockquote><p>主要是对java应用程序的资源和性能进行实时的命令行监控，包括了对heap size和垃圾回收状况的监控。</p><ol><li>jstat <code>-&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</code></li><li>option：我们经常使用的选项有gc、gcutil</li><li>vmid：java进程id</li><li>interval：间隔时间，单位为毫秒</li><li>count：打印次数</li></ol></blockquote><h2 id="jstat-gc-pid-5000-20"><a href="#jstat-gc-pid-5000-20" class="headerlink" title="jstat -gc [pid] 5000 20"></a>jstat -gc [pid] 5000 20</h2><blockquote><p>S0C:年轻代第一个survivor的容量（字节）<br>S1C：年轻代第二个survivor的容量（字节）<br>S0U：年轻代第一个survivor已使用的容量（字节）<br>S1U：年轻代第二个survivor已使用的容量（字节）<br>EC：年轻代中Eden的空间（字节）<br>EU：年代代中Eden已使用的空间（字节）<br>OC：老年代的容量（字节）<br>OU:老年代中已使用的空间（字节）<br>PC：永久代的容量<br>PU：永久代已使用的容量<br>YGC：从应用程序启动到采样时年轻代中GC的次数<br>YGCT:从应用程序启动到采样时年轻代中GC所使用的时间（单位：S）<br>FGC：从应用程序启动到采样时老年代中GC（FULL GC）的次数<br>FGCT：从应用程序启动到采样时老年代中GC所使用的时间（单位：S）</p></blockquote><h2 id="jstat-gcutil-pid-5000-20"><a href="#jstat-gcutil-pid-5000-20" class="headerlink" title="jstat -gcutil [pid] 5000 20"></a>jstat -gcutil [pid] 5000 20</h2><blockquote><p>s0:年轻代中第一个survivor已使用的占当前容量百分比<br>s1:年轻代中第二个survivor已使用的占当前容量百分比<br>E:年轻代中Eden已使用的占当前容量百分比<br>O:老年代中已使用的占当前容量百分比<br>P:永久代中已使用的占当前容量百分比</p></blockquote><h1 id="jhat-内存分析工具"><a href="#jhat-内存分析工具" class="headerlink" title="jhat 内存分析工具"></a>jhat 内存分析工具</h1><blockquote><p>主要用来解析java堆dump并启动一个web服务器，然后就可以在浏览器中查看堆的dump文件了。<br>生成dump文件的方法前面已经介绍了，这边主要介绍如何解析java堆转储文件，并启动一个web server</p></blockquote><h2 id="jhat-heapdump"><a href="#jhat-heapdump" class="headerlink" title="jhat heapdump"></a>jhat heapdump</h2><blockquote><p>这个命令将heapdump文件转换成html格式，并且启动一个http服务，默认端口为7000。<br>如果端口冲突，可以使用以下命令指定端口：jhat -port 4000 heapdump</p></blockquote><h1 id="jinfo-查看正在运行的java运用程序的扩展参数"><a href="#jinfo-查看正在运行的java运用程序的扩展参数" class="headerlink" title="jinfo 查看正在运行的java运用程序的扩展参数"></a>jinfo 查看正在运行的java运用程序的扩展参数</h1><blockquote><p>jinfo可以用来查看正在运行的java运用程序的扩展参数，甚至支持在运行时动态地更改部分参数。<br>基本使用语法如下： jinfo -&lt; option &gt; &lt; pid &gt; ，其中option可以为以下信息：<br>-flag&lt; name &gt;: 打印指定java虚拟机的参数值<br>-flag [+|-]&lt; name &gt;：设置或取消指定java虚拟机参数的布尔值<br>-flag &lt; name &gt;=&lt; value &gt;：设置指定java虚拟机的参数的值</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的命令显示了新生代对象晋升到老年代对象的最大年龄。在运行程序运行时并没有指定这个参数，但是通过jinfo，可以查看这个参数的当前的值。</span></span><br><span class="line">jinfo -flag MaxTenuringThreshold 2500</span><br><span class="line"><span class="comment">#下面的命令显示是否打印gc详细信息：</span></span><br><span class="line">jinfo -flag PrintGCDetails 2500</span><br><span class="line"><span class="comment">#下面的命令在运用程序运行时动态打开打印详细gc信息开关：</span></span><br><span class="line">jinfo -flag +PrintGCDetails 2500</span><br><span class="line">jinfo -flag PrintGCDetails 2500</span><br></pre></td></tr></table></figure><blockquote><p>注意事项：jinfo虽然可以在java程序运行时动态地修改虚拟机参数，但并不是所有的参数都支持动态修改。</p></blockquote><h1 id="jcmd-可以用来导出堆，查看java进程，导出线程信息，执行GC等"><a href="#jcmd-可以用来导出堆，查看java进程，导出线程信息，执行GC等" class="headerlink" title="jcmd 可以用来导出堆，查看java进程，导出线程信息，执行GC等"></a>jcmd 可以用来导出堆，查看java进程，导出线程信息，执行GC等</h1><blockquote><p>在JDK 1.7之后，新增了一个命令行工具jcmd。它是一个多功能工具，可以用来导出堆，查看java进程，导出线程信息，执行GC等。jcmd拥有jmap的大部分功能，Oracle官方建议使用jcmd代替jmap。</p></blockquote><h2 id="jcmd-l-命令列出当前运行的所有虚拟机"><a href="#jcmd-l-命令列出当前运行的所有虚拟机" class="headerlink" title="jcmd -l 命令列出当前运行的所有虚拟机"></a>jcmd -l 命令列出当前运行的所有虚拟机</h2><h2 id="jcmd-pid-help-针对每一个虚拟机，可以使用help命令列出该虚拟机支持的所有命令"><a href="#jcmd-pid-help-针对每一个虚拟机，可以使用help命令列出该虚拟机支持的所有命令" class="headerlink" title="jcmd [pid] help 针对每一个虚拟机，可以使用help命令列出该虚拟机支持的所有命令"></a>jcmd [pid] help 针对每一个虚拟机，可以使用help命令列出该虚拟机支持的所有命令</h2><blockquote><p>VM.native_memory<br>VM.commercial_features<br>GC.rotate_log<br>ManagementAgent.stop<br>ManagementAgent.start_local<br>ManagementAgent.start<br>Thread.print，                         打印线程栈信息<br>GC.class_histogram，              查看系统中类统计信息<br>GC.heap_dump，                    导出堆信息，与jmap -dump功能一样<br>GC.run_finalization，               触发finalize()<br>GC.run，                                触发gc()<br>VM.uptime，                           VM启动时间<br>VM.flags，                              获取JVM启动参数<br>VM.system_properties，          获取系统Properties<br>VM.command_line，                 启动时命令行指定的参数<br>VM.version<br>help</p></blockquote><h1 id="jconsole-简易的可视化控制台"><a href="#jconsole-简易的可视化控制台" class="headerlink" title="jconsole 简易的可视化控制台"></a>jconsole 简易的可视化控制台</h1><h1 id="jvisualvm-功能强大的控制台"><a href="#jvisualvm-功能强大的控制台" class="headerlink" title="jvisualvm 功能强大的控制台"></a>jvisualvm 功能强大的控制台</h1>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM参数</title>
      <link href="/blog/2022/04/28/JVM/JVM%E5%8F%82%E6%95%B0/"/>
      <url>/blog/2022/04/28/JVM/JVM%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>-Xms20m 指定堆空间最小内存为20m<br>-Xmx20m 指定堆空间最大内存为20m<br>-Xmn10m 指定新生代的大小为10m<br>-XX:PermSize 配置初始永久区的大小<br>-XX:MaxPermSize 配置最大永久区的大小<br>-XX:+HeapDumpOnOutOfMemoryError    内存溢出时，导出整个堆的信息，和下一个参数配合使用<br>-XX:+PrintGCDetails gc发生时，打印更详细的日志<br>-XX:SurvivorRatio=8 决定新生代中Eden区与一个Survivor区的空间比例是8:1<br>-XX:PretenureSizeThreshold 大于这个设置值的对象直接在老年代分配(目的:避免在Eden区及两个Survivor区之间发生大量的内存复制)(只在Serial和ParNew两款收集器有效)<br>-XX:+UseSerialGC 使用Serial收集器<br>-XX:MaxTenuringThreshold=1 对象晋升老年代的年龄阙值<br>-XX:+PrintTenuringDistribution 打印对象年龄</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PLSQL安装</title>
      <link href="/blog/2022/04/28/Install/PLSQL/"/>
      <url>/blog/2022/04/28/Install/PLSQL/</url>
      
        <content type="html"><![CDATA[<h1 id="环境变量："><a href="#环境变量：" class="headerlink" title="环境变量："></a>环境变量：</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NLS_LANG：SIMPLIFIED CHINESE_CHINA.ZHS16GBK</span><br><span class="line">ORACLE_HOME：D:\Java\oracle\instantclient_12_2</span><br><span class="line">TNS_ADMIN：D:\Java\oracle\instantclient_12_2\NETWORK\ADMIN</span><br><span class="line">PATH:  D:\Java\oracle\instantclient_12_2</span><br></pre></td></tr></table></figure><p>文件：</p><blockquote><p>D:\Java\oracle\instantclient_12_2\NETWORK\ADMIN\tnsnames.ora</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NEWBOSS =</span><br><span class="line">  (DESCRIPTION =</span><br><span class="line">    (ADDRESS_LIST =</span><br><span class="line">      (ADDRESS = (PROTOCOL = TCP)(HOST = 10.8.73.16)(PORT = 1521))</span><br><span class="line">    )</span><br><span class="line">    (CONNECT_DATA =</span><br><span class="line">      (SERVICE_NAME = NBUNIDB)</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找不到或无法加载主类</title>
      <link href="/blog/2022/04/28/IDEA/%E6%89%BE%E4%B8%8D%E5%88%B0%E6%88%96%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E4%B8%BB%E7%B1%BB/"/>
      <url>/blog/2022/04/28/IDEA/%E6%89%BE%E4%B8%8D%E5%88%B0%E6%88%96%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E4%B8%BB%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="IDEA-ERROR：找不到或无法加载主类"><a href="#IDEA-ERROR：找不到或无法加载主类" class="headerlink" title="IDEA ERROR：找不到或无法加载主类"></a>IDEA ERROR：找不到或无法加载主类</h1><p><img src="/blog/img/md/IDEA-01.png" alt="图1"></p><blockquote><p>将设置的source folder删除</p></blockquote><p><img src="/blog/img/md/IDEA-02.png" alt="图2"></p>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决docker下载缓慢问题</title>
      <link href="/blog/2022/04/28/Docker/%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F/"/>
      <url>/blog/2022/04/28/Docker/%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="配置镜像"><a href="#配置镜像" class="headerlink" title="配置镜像"></a>配置镜像</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://registry.docker-cn.com&quot;</span>,<span class="string">&quot;http://hub-mirror.c.163.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><blockquote><p>通过 dig @114.114.114.114 registry-1.docker.io 找到可用IP地址<br>修改/etc/hosts强制docker.io相关的域名解析到其它可用IP</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker常用命令</title>
      <link href="/blog/2022/04/28/Docker/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/blog/2022/04/28/Docker/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hostname</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h1 id="服务器传输"><a href="#服务器传输" class="headerlink" title="服务器传输"></a>服务器传输</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp file root@192.168.1.1:/root</span><br><span class="line"><span class="comment">#传输目录</span></span><br><span class="line">scp -r dir root@192.168.1.1:/root</span><br></pre></td></tr></table></figure><h1 id="添加node的标签"><a href="#添加node的标签" class="headerlink" title="添加node的标签"></a>添加node的标签</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node update --label-add role=mic node01</span><br></pre></td></tr></table></figure><h1 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node update --label-rm role izbp17i0ndca7tu88rknmvz</span><br></pre></td></tr></table></figure><h1 id="配置镜像地址"><a href="#配置镜像地址" class="headerlink" title="配置镜像地址"></a>配置镜像地址</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json </span><br></pre></td></tr></table></figure><h1 id="清理悬空镜像"><a href="#清理悬空镜像" class="headerlink" title="清理悬空镜像"></a>清理悬空镜像</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -f <span class="string">&quot;dangling=true&quot;</span> -q)</span><br></pre></td></tr></table></figure><h1 id="删除已停止的镜像"><a href="#删除已停止的镜像" class="headerlink" title="删除已停止的镜像"></a>删除已停止的镜像</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm `docker ps -a | grep Exited | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>`</span><br></pre></td></tr></table></figure><h1 id="创建容器并启动"><a href="#创建容器并启动" class="headerlink" title="创建容器并启动"></a>创建容器并启动</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name myjdk01 d5d4d6126200</span><br></pre></td></tr></table></figure><h1 id="修改镜像"><a href="#修改镜像" class="headerlink" title="修改镜像"></a>修改镜像</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m <span class="string">&quot;add fontconfig&quot;</span> 0b2616b0e5a8 ouruser/sinatra:v2</span><br></pre></td></tr></table></figure><h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service scale service=4</span><br></pre></td></tr></table></figure><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yum list installed | grep docker</span><br><span class="line"></span><br><span class="line">sudo yum remove docker-ce.x86_64 containerd.io.x86_64 docker-ce-cli.x86_64 docker-ce-rootless-extras.x86_64 docker-scan-plugin.x86_64</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">sudo yum makecache fast</span><br><span class="line">sudo yum -y install docker-ce-19.03.9 docker-ce-cli-19.03.9 containerd.io</span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器进入的方式</title>
      <link href="/blog/2022/04/28/Docker/%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/blog/2022/04/28/Docker/%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="使用docker-attach进入Docker容器"><a href="#使用docker-attach进入Docker容器" class="headerlink" title="使用docker attach进入Docker容器"></a>使用docker attach进入Docker容器</h1><blockquote><p>创建一个守护态的Docker容器，使用docker attach命令进入容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd ubuntu:14.04 /bin/bash</span><br><span class="line">docker attach 44fc0f0582d9</span><br></pre></td></tr></table></figure><blockquote><p>使用该命令有一个问题。当多个窗口同时使用该命令进入该容器时，所有的窗口都会同步显示。如果有一个窗口阻塞了，那么其他窗口也无法再进行操作。<br>因为这个原因，所以docker attach命令不太适合于生产环境，平时自己开发应用时可以使用该命令</p></blockquote><h1 id="使用docker-exec进入Docker容器"><a href="#使用docker-exec进入Docker容器" class="headerlink" title="使用docker exec进入Docker容器"></a>使用docker exec进入Docker容器</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps  </span><br><span class="line">docker <span class="built_in">exec</span> -it 775c7c9ee1e1 /bin/bash </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker swarm</title>
      <link href="/blog/2022/04/28/Docker/Swarm/"/>
      <url>/blog/2022/04/28/Docker/Swarm/</url>
      
        <content type="html"><![CDATA[<h1 id="docker-swarm"><a href="#docker-swarm" class="headerlink" title="docker swarm"></a>docker swarm</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init --advertise-addr 192.168.172.136</span><br></pre></td></tr></table></figure><h2 id="新的主机被当做manager（获取token）"><a href="#新的主机被当做manager（获取token）" class="headerlink" title="新的主机被当做manager（获取token）"></a>新的主机被当做manager（获取token）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join-token manager</span><br></pre></td></tr></table></figure><h2 id="新的主机被当做worker（获取token）"><a href="#新的主机被当做worker（获取token）" class="headerlink" title="新的主机被当做worker（获取token）"></a>新的主机被当做worker（获取token）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join-token worker</span><br></pre></td></tr></table></figure><h2 id="升级为manager"><a href="#升级为manager" class="headerlink" title="升级为manager"></a>升级为manager</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node promote</span><br></pre></td></tr></table></figure><h2 id="降级为work"><a href="#降级为work" class="headerlink" title="降级为work"></a>降级为work</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node demote</span><br></pre></td></tr></table></figure><h2 id="创建自定义的overlay网络"><a href="#创建自定义的overlay网络" class="headerlink" title="创建自定义的overlay网络"></a>创建自定义的overlay网络</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver overlay my-overlay-network</span><br></pre></td></tr></table></figure><h2 id="管理器节点离开Docker-Swarm模式"><a href="#管理器节点离开Docker-Swarm模式" class="headerlink" title="管理器节点离开Docker Swarm模式"></a>管理器节点离开Docker Swarm模式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm leave --force</span><br></pre></td></tr></table></figure><h2 id="普通节点离开Docker-Swarm模式"><a href="#普通节点离开Docker-Swarm模式" class="headerlink" title="普通节点离开Docker Swarm模式"></a>普通节点离开Docker Swarm模式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm leave</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决docker下载的mysql连不上的问题</title>
      <link href="/blog/2022/04/28/Docker/mysql%E8%BF%9E%E4%B8%8D%E4%B8%8A/"/>
      <url>/blog/2022/04/28/Docker/mysql%E8%BF%9E%E4%B8%8D%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="原因查找"><a href="#原因查找" class="headerlink" title="原因查找"></a>原因查找</h1><blockquote><p>通过查看网上别人遇到的相关问题，发现是由于navicat版本的问题，出现连接失败的原因：mysql8 之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password。并提供了两种解决方案</p></blockquote><ol><li>升级navicat，由于navicat是收费的，个人感觉升级会比较麻烦点。</li><li>把用户密码登录的加密规则还原成mysql_native_password这种加密方式，本人选择第二种解决方案</li></ol><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop1 ~]<span class="comment"># docker exec -it mysql02 bash</span></span><br><span class="line">root@a4dd7e1182e7:/<span class="comment"># mysql -uroot -p123456</span></span><br></pre></td></tr></table></figure><ol><li>通过mysql -uroot -p进入mysql的命令行模式</li><li>输入命令修改相关机密方法<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="string">&#x27;password&#x27;</span> PASSWORD EXPIRE NEVER;</span><br><span class="line"><span class="comment">#这里的password是你正在使用的密码</span></span><br><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="string">&#x27;password&#x27;</span>;</span><br><span class="line"><span class="comment">#更新一下用户的密码这里的password为你修改的新密码。</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"> <span class="comment">#刷新权限，使自己的修改生效。</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>这时还是连接不上，然后通过telnet3306数据库对应的接口，出现了8.0.11;S”3&lt;VN,.Y\k4Ycaching_sha2_password这个信息，是修改没有生效还是其他原因？重启容器之后还是不行。<br>然后use mysql;<br>这时发现了问题，原理刚刚修改的是localhost，对于非本机的连接密码校验规则还是没有变。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alter user <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27;password&#x27;</span> password expire never;</span><br><span class="line">alter user <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified with mysql_native_password by <span class="string">&#x27;why&#x27;</span>;<span class="comment">#why是自己新修改的密码。</span></span><br><span class="line">flush privileges;<span class="comment">#再次刷新一下权限配置。</span></span><br><span class="line"><span class="comment">#为了确定下，重新查一下</span></span><br><span class="line">select user,host,plugin from user <span class="built_in">where</span> user=<span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure><p>修改好了，再用宿主的window电脑访问数据库。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Registry</title>
      <link href="/blog/2022/04/28/Docker/Registry/"/>
      <url>/blog/2022/04/28/Docker/Registry/</url>
      
        <content type="html"><![CDATA[<h1 id="查看仓库"><a href="#查看仓库" class="headerlink" title="查看仓库"></a>查看仓库</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:5000/v2/_catalog</span><br></pre></td></tr></table></figure><h1 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> registry rm -rf /var/lib/registry/docker/registry/v2/repositories/tomcat</span><br><span class="line">docker <span class="built_in">exec</span> registry bin/registry garbage-collect /etc/docker/registry/config.yml</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA配置证书连接Docker</title>
      <link href="/blog/2022/04/28/Docker/IDEA%E9%85%8D%E7%BD%AE%E8%AF%81%E4%B9%A6%E8%BF%9E%E6%8E%A5Docker/"/>
      <url>/blog/2022/04/28/Docker/IDEA%E9%85%8D%E7%BD%AE%E8%AF%81%E4%B9%A6%E8%BF%9E%E6%8E%A5Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="如果不需要证书，直接更改docker服务文件"><a href="#如果不需要证书，直接更改docker服务文件" class="headerlink" title="如果不需要证书，直接更改docker服务文件"></a>如果不需要证书，直接更改docker服务文件</h1><blockquote><p>服务文件名是docker.service，我发现不同安装方式路径会不一样，可以使用 find / -name docker.service 查找到指定文件，然后更改，直接在ExecStart=/usr/bin/dockerd下添加两句即可：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd \</span><br><span class="line">-H tcp://0.0.0.0:2375 \</span><br><span class="line">-H unix:///var/run/docker.sock \</span><br></pre></td></tr></table></figure><h1 id="下面是生成证书，并且配置到idea中的步骤"><a href="#下面是生成证书，并且配置到idea中的步骤" class="headerlink" title="下面是生成证书，并且配置到idea中的步骤"></a>下面是生成证书，并且配置到idea中的步骤</h1><ol><li>新建一个目录，在目录执行以下命令，输入两次密码，需要记住后面会用到<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -aes256 -out ca-key.pem 4096</span><br></pre></td></tr></table></figure></li><li>执行以下命令，输入密码，然后依次输入国家是 CN，省例如是Shanghai、市Shanghai、组织名称、组织单位、姓名或服务器名、邮件地址，都可以随意填写<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem</span><br></pre></td></tr></table></figure></li><li>执行生成服务器端key证书文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out server-key.pem 4096</span><br></pre></td></tr></table></figure></li><li>ip需要换成自己服务器的外网ip地址，或者域名都可以<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -subj <span class="string">&quot;/CN=10.8.73.31&quot;</span> -sha256 -new -key server-key.pem -out server.csr</span><br></pre></td></tr></table></figure></li><li>配置白名单，多个用逗号隔开，例如： IP:192.168.1.111,IP:0.0.0.0，这里需要注意，虽然0.0.0.0可以匹配任意，但是仍然需要配置你的服务器外网ip，如果省略会造成错误，后面会讲到<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> subjectAltName = IP:10.8.73.31,IP:0.0.0.0 &gt;&gt; extfile.cnf</span><br></pre></td></tr></table></figure></li><li>把 extendedKeyUsage = serverAuth 键值设置到extfile.cnf文件里，限制扩展只能用在服务器认证<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> extendedKeyUsage = serverAuth &gt;&gt; extfile.cnf</span><br></pre></td></tr></table></figure></li><li>执行以下命令，输入之前设置的密码，然后会生成签名的证书<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 365 -sha256 -<span class="keyword">in</span> server.csr -CA ca.pem -CAkey ca-key.pem \-CAcreateserial -out server-cert.pem -extfile extfile.cnf</span><br></pre></td></tr></table></figure></li><li>生成例如idea等客户端需要用到的密钥文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out key.pem 4096</span><br></pre></td></tr></table></figure></li><li>生成客户端签名请求需要用到的临时文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -subj <span class="string">&#x27;/CN=client&#x27;</span> -new -key key.pem -out client.csr</span><br></pre></td></tr></table></figure></li><li>继续设置证书扩展属性<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> extendedKeyUsage = clientAuth &gt;&gt; extfile.cnf</span><br></pre></td></tr></table></figure></li><li>输入之前的密码生成认证证书，生成正式签名证书<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 365 -sha256 -<span class="keyword">in</span> client.csr -CA ca.pem -CAkey ca-key.pem \-CAcreateserial -out cert.pem -extfile extfile.cnf</span><br></pre></td></tr></table></figure></li><li>删除生成的临时文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf client.csr server.csr</span><br></pre></td></tr></table></figure></li><li>修改证书为只读权限保证证书安全<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod -v 0400 ca-key.pem key.pem server-key.pem</span><br><span class="line">chmod -v 0444 ca.pem server-cert.pem cert.pem</span><br></pre></td></tr></table></figure></li><li>复制服务端需要用到的证书到docker配置目录下便于识别使用：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp server-cert.pem ca.pem server-key.pem /etc/docker/</span><br></pre></td></tr></table></figure></li><li>修改docker配置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /lib/systemd/system/docker.service</span><br><span class="line"></span><br><span class="line">ExecStart=/usr/bin/dockerd --tlsverify --tlscacert=/etc/docker/ca.pem --tlscert=/etc/docker/server-cert.pem --tlskey=/etc/docker/server-key.pem -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock</span><br></pre></td></tr></table></figure></li><li>开放防火墙的2375的端口，如果防火墙已经关闭，忽略此项<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=2375/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></li><li>重载服务并重启docker<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload &amp;&amp; systemctl restart docker</span><br></pre></td></tr></table></figure></li><li>保存证书客户端文件到本地，我这里用的是sz命令，ftp也可以只要能放到本地客户端即可<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sz ca.pem cert.pem key.pem</span><br></pre></td></tr></table></figure></li><li>测试一下证书是否配置成功，如果成功，会输出证书相关信息，如果有fail，请检查证书<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker --tlsverify --tlscacert=ca.pem --tlscert=cert.pem --tlskey=key.pem -H=10.8.73.31:2375 version</span><br></pre></td></tr></table></figure></li><li>IDEA配置docker<br><img src="/blog/img/md/Docker/01.jpg" alt="图1"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校验文件</title>
      <link href="/blog/2022/04/28/Bash/%E6%A0%A1%E9%AA%8C%E6%96%87%E4%BB%B6/"/>
      <url>/blog/2022/04/28/Bash/%E6%A0%A1%E9%AA%8C%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><blockquote><p>certutil -hashfile [文件名] MD5</p></blockquote><h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><blockquote><p>md5sum [文件名]</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
